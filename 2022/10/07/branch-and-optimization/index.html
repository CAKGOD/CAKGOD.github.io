<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="1. 参考文章How branches influence the performance of your code and what can you do about it? 2. 概述本文属于上述参考文章的一篇读后感，该文章讲了一些关于分支对于软件性能的影响，以及如何通过优化代码中的分支来提高性能。因为之前的工作中也涉及到类似的工作，顺路在这里重新学习并总结一下。 3. 详述分支（branch">
<meta property="og:type" content="article">
<meta property="og:title" content="分支对性能的影响以及分支优化">
<meta property="og:url" content="http://cakgod.github.io/2022/10/07/branch-and-optimization/index.html">
<meta property="og:site_name" content="CAKGOD&#39;s blog">
<meta property="og:description" content="1. 参考文章How branches influence the performance of your code and what can you do about it? 2. 概述本文属于上述参考文章的一篇读后感，该文章讲了一些关于分支对于软件性能的影响，以及如何通过优化代码中的分支来提高性能。因为之前的工作中也涉及到类似的工作，顺路在这里重新学习并总结一下。 3. 详述分支（branch">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-10-07T06:06:06.000Z">
<meta property="article:modified_time" content="2023-10-09T07:04:41.990Z">
<meta property="article:author" content="CAKGOD">
<meta property="article:tag" content="优化">
<meta property="article:tag" content="读后感">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>分支对性能的影响以及分支优化</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="CAKGOD's blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2022/10/09/video-stabilization/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2021/05/10/compiler-optimization/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://cakgod.github.io/2022/10/07/branch-and-optimization/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&text=分支对性能的影响以及分支优化"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&title=分支对性能的影响以及分支优化"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&is_video=false&description=分支对性能的影响以及分支优化"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=分支对性能的影响以及分支优化&body=Check out this article: http://cakgod.github.io/2022/10/07/branch-and-optimization/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&title=分支对性能的影响以及分支优化"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&title=分支对性能的影响以及分支优化"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&title=分支对性能的影响以及分支优化"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&title=分支对性能的影响以及分支优化"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&name=分支对性能的影响以及分支优化&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://cakgod.github.io/2022/10/07/branch-and-optimization/&t=分支对性能的影响以及分支优化"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">1. 参考文章</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">2. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%AF%A6%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text">3. 详述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-CPU%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. CPU相关的知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-CPU%E5%A4%84%E7%90%86%E5%88%86%E6%94%AF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. CPU处理分支的几种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%88%86%E6%94%AF%E5%AF%B9%E4%BA%8E%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. 分支对于性能的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%88%86%E6%94%AF%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. 分支优化手段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E4%BC%98%E5%8C%96%E8%BF%9E%E6%8E%A5%E6%9D%A1%E4%BB%B6%EF%BC%88join-condition%EF%BC%89"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1. 优化连接条件（join condition）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E4%BC%98%E5%8C%96if-else%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2. 优化if&#x2F;else结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8%E6%9B%BF%E6%8D%A2switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3. 使用查找表替换switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E5%B0%86%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E6%83%85%E5%86%B5%E7%A7%BB%E5%87%BAswitch%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.4.4.</span> <span class="toc-text">3.4.4. 将最常见的情况移出switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-%E9%87%8D%E5%86%99%E8%BF%9E%E6%8E%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.4.5.</span> <span class="toc-text">3.4.5. 重写连接条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-6-%E5%90%91%E7%BC%96%E8%AF%91%E5%99%A8%E5%BB%BA%E8%AE%AE%E5%93%AA%E4%B8%AA%E5%88%86%E6%94%AF%E6%A6%82%E7%8E%87%E6%9B%B4%E9%AB%98"><span class="toc-number">3.4.6.</span> <span class="toc-text">3.4.6. 向编译器建议哪个分支概率更高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-7-%E4%BD%BF%E7%94%A8%E6%97%A0%E5%88%86%E6%94%AF%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.7.</span> <span class="toc-text">3.4.7. 使用无分支算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-8-%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%80%8C%E4%B8%8D%E6%98%AF%E5%88%86%E6%94%AF"><span class="toc-number">3.4.8.</span> <span class="toc-text">3.4.8. 使用条件加载而不是分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-9-%E9%80%9A%E8%BF%87%E7%AE%97%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%88%86%E6%94%AF"><span class="toc-number">3.4.9.</span> <span class="toc-text">3.4.9. 通过算术实现无分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-10-%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81%E4%BB%A5%E9%81%BF%E5%85%8D%E5%88%86%E6%94%AF"><span class="toc-number">3.4.10.</span> <span class="toc-text">3.4.10. 重新组织代码以避免分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-11-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF"><span class="toc-number">3.4.11.</span> <span class="toc-text">3.4.11. 使用模板删除分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-12-%E9%81%BF%E5%85%8D%E5%88%86%E6%94%AF%E7%9A%84%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7"><span class="toc-number">3.4.12.</span> <span class="toc-text">3.4.12. 避免分支的其他一些技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.5.</span> <span class="toc-text">3.5. 实验</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        分支对性能的影响以及分支优化
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">CAKGOD</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-10-07T06:06:06.000Z" class="dt-published" itemprop="datePublished">2022-10-07</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a>, <a class="p-category" href="/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/" rel="tag">读后感</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="1-参考文章"><a href="#1-参考文章" class="headerlink" title="1. 参考文章"></a>1. 参考文章</h1><p><a target="_blank" rel="noopener" href="https://johnnysswlab.com/how-branches-influence-the-performance-of-your-code-and-what-can-you-do-about-it/">How branches influence the performance of your code and what can you do about it?</a></p>
<h1 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h1><p>本文属于上述参考文章的一篇读后感，该文章讲了一些关于分支对于软件性能的影响，以及如何通过优化代码中的分支来提高性能。因为之前的工作中也涉及到类似的工作，顺路在这里重新学习并总结一下。</p>
<h1 id="3-详述"><a href="#3-详述" class="headerlink" title="3. 详述"></a>3. 详述</h1><p>分支（branch，jump）是非常常见的指令类型之一。根据统计，平均每五条指令就要遇到一条分支指令。对于CPU来说，有效的分支实现对于良好的性能至关重要。</p>
<h2 id="3-1-CPU相关的知识"><a href="#3-1-CPU相关的知识" class="headerlink" title="3.1. CPU相关的知识"></a>3.1. CPU相关的知识</h2><p>许多现代处理器（但不是全部，特别是嵌入式系统中使用的一些处理器）都具有以下部分或全部功能： </p>
<ul>
<li><p><em>流水线（pipeline）</em>：流水线允许CPU同时执行多条指令。CPU将每条指令的执行分为几个阶段，并且每条指令处于不同的执行阶段。汽车工厂也采用同样的原理：在任何给定时间，工厂同时生产五十辆汽车，例如，一辆汽车正在喷漆，另一辆汽车正在安装发动机，第三辆汽车正在安装车灯，流水线可以很短，只有几个阶段（例如三个阶段），也可以很长，有很多阶段（例如二十个阶段）。</p>
</li>
<li><p><em>乱序执行（OOE，out of order exexcution）</em>：从程序员的角度来看，程序运行一条又一条指令。在CPU中情况看起来完全不同：CPU不需要按照指令在内存中出现的顺序来执行它们。在执行过程中，一些指令会被阻塞在CPU中等待来自内存的数据或者等待来自其他指令的数据。CPU可以向前看并执行稍后出现但不会被阻塞的指令。当被阻止的指令的数据变得可用时，之前未被阻止的指令已经完成。这可以节省CPU指令执行周期。</p>
</li>
<li><p><em>推断执行（speculative exexcution）</em>：即使不能100%确定需要执行指令，CPU也可以开始执行指令。例如，它会猜测条件分支指令的目的地，然后在100%确定会采用分支之前开始执行分支目的地的指令。如果后来CPU发现猜测（推断）是错误的，它将取消推断执行指令的结果，并且一切都将显示为没有进行任何推断。</p>
</li>
<li><p><em>分支预测（branch prediction）</em>：现代CPU具有特殊电路，每个分支指令都会记住其先前的结果：采用分支或未采用分支。当下次执行相同的分支指令时，CPU将使用该信息来猜测分支的目的地，然后在分支目的地开始推断执行指令。如果分支预测器正确，这将导致性能加速。</p>
</li>
</ul>
<p>所有现代处理器都具有pipeline，以便更好地利用CPU资源。并大多数都有分支预测和推断执行。就乱序执行而言，大多数低端低功耗处理器不具备此功能，因为它消耗大量电量且速度提升并不大。</p>
<h2 id="3-2-CPU处理分支的几种方法"><a href="#3-2-CPU处理分支的几种方法" class="headerlink" title="3.2. CPU处理分支的几种方法"></a>3.2. CPU处理分支的几种方法</h2><p>当分支指令进入处理器流水线时，在对其进行解码并计算其目的地之前，分支目的地是未知的。分支指令之后的指令可以是：直接跟随分支的指令或分支目的地处的指令。CPU对于分支指令的处理可以有三种方式：</p>
<ul>
<li><p><em>暂停流水线（pause pipeline，stall pipeline）</em>：暂停流水线并停止解码指令，直到分支指令被解码并且知道分支目的地。然后它可以使用正确的指令恢复加载流水线。</p>
</li>
<li><p>加载紧随分支之后的指令。万一后来发现这是错误的选择，处理器将需要刷新流水线并开始从分支目的地加载正确的指令。 </p>
</li>
<li><p>询问分支预测器是否应该加载紧接在分支之后的指令或分支目的地处的指令。分支预测器还需要告诉流水线分支目的地在哪里（否则将新指令加载到流水线中并将需要等待流水线解析分支目的地）。</p>
</li>
</ul>
<p>采用第一种方式的处理器现在很少见，除了一些非常低端的嵌入式处理器，仅仅让处理器什么都不做就是浪费资源。因此大多数处理器会执行采用第二种方式，常见于低端嵌入式系统和低功耗处理器。采用第三种方式的处理器是常见的台式机和笔记本电脑CPU以及高性能CPU。</p>
<h2 id="3-3-分支对于性能的影响"><a href="#3-3-分支对于性能的影响" class="headerlink" title="3.3. 分支对于性能的影响"></a>3.3. 分支对于性能的影响</h2><p>主要介绍以下两点影响：</p>
<ul>
<li><p>在某些处理器上，指令自上而下“贯穿”（fall through）的开销远远小于分支指令的开销。</p>
</li>
<li><p>自动向量化（auto vectorization）是现代处理器中比较常用的提高性能的手段，分支的加入通常导致代码无法向量化。</p>
</li>
</ul>
<h2 id="3-4-分支优化手段"><a href="#3-4-分支优化手段" class="headerlink" title="3.4. 分支优化手段"></a>3.4. 分支优化手段</h2><p>本文重点不在于介绍分支预测，而是较少如何优化代码达到去分支或减少分支来提高软件性能。</p>
<h3 id="3-4-1-优化连接条件（join-condition）"><a href="#3-4-1-优化连接条件（join-condition）" class="headerlink" title="3.4.1. 优化连接条件（join condition）"></a>3.4.1. 优化连接条件（join condition）</h3><p>连接条件是<code>(cond1 &amp;&amp; cond2)</code>或<code>(cond1 || cond2)</code>类型的条件。根据C和C++标准，在<code>(cond1 &amp;&amp; cond2)</code>的情况下，如果<code>cond1</code>为<code>false</code>，则不会评估<code>cond2</code>。类似地，在<code>(cond1 || cond2)</code>的情况下，如果<code>cond1</code>为<code>true</code>，则不会评估<code>cond2</code>。</p>
<h3 id="3-4-2-优化if-else结构"><a href="#3-4-2-优化if-else结构" class="headerlink" title="3.4.2. 优化if&#x2F;else结构"></a>3.4.2. 优化if&#x2F;else结构</h3><p>以如下代码为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0</span>) &#123; </span><br><span class="line">   <span class="built_in">do_something_else</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">do_something_yet_else</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在考虑<code>(a &lt; 0)</code>的概率为70%，<code>(a &gt; 0)</code>为20%，<code>(a == 0)</code>为10%。在这种情况下，重新排列上述代码是最合乎逻辑的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="built_in">do_something_yet_else</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123; </span><br><span class="line">   <span class="built_in">do_something</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">do_something_else</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-3-使用查找表替换switch语句"><a href="#3-4-3-使用查找表替换switch语句" class="headerlink" title="3.4.3. 使用查找表替换switch语句"></a>3.4.3. 使用查找表替换switch语句</h3><p>在删除分支时，查找表（lookup table, LUT）有时会很方便。不幸的是，在switch语句中，分支在大多数情况下很容易预测，因此这种优化可能不会产生任何效果。示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY: <span class="keyword">return</span> <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY: <span class="keyword">return</span> <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">case</span> SUNDAY: <span class="keyword">return</span> <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的语句可以使用LUT来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (day &lt; MONDAY || day &gt; SUNDAY) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">char</span>* days_to_string = &#123; <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, ... , <span class="string">&quot;Sunday&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">return</span> days_to_string[day - MONDAY];</span><br></pre></td></tr></table></figure>

<p>通常，编译器可以通过用查找表替换开关来为完成这项工作。</p>
<h3 id="3-4-4-将最常见的情况移出switch语句"><a href="#3-4-4-将最常见的情况移出switch语句" class="headerlink" title="3.4.4. 将最常见的情况移出switch语句"></a>3.4.4. 将最常见的情况移出switch语句</h3><p>如果使用switch命令并且其中一种情况似乎最常见，可以将其移出switch并给予特殊处理。继续上一节的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">day <span class="title">get_first_workday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::chrono::weekday first_workday = <span class="built_in">read_first_workday</span>();</span><br><span class="line">    <span class="keyword">if</span> (first_workday == Monday) &#123; <span class="keyword">return</span> day::Monday; &#125;</span><br><span class="line">    <span class="keyword">switch</span>(first_workday) &#123; </span><br><span class="line">        <span class="keyword">case</span> Tuesday: <span class="keyword">return</span> day::Tueasday;</span><br><span class="line">        ....</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-5-重写连接条件"><a href="#3-4-5-重写连接条件" class="headerlink" title="3.4.5. 重写连接条件"></a>3.4.5. 重写连接条件</h3><p>如前所述，在连接条件的情况下，如果第一个条件具有特定值，则根本不需要评估第二个条件。编译器是如何做到这一点的？以下面的函数为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i] &gt; x &amp;&amp; a[i] &lt; y) &#123;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在假设<code>a[i] &gt; x</code>和<code>a[i] &lt; y</code>评估起来很便宜（所有数据都在寄存器或缓存中）但难以预测。该序列将转换为以下伪汇编程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if_not (a[i] &gt; x) <span class="keyword">goto</span> ENDIF;</span><br><span class="line">if_not (a[i] &lt; y) <span class="keyword">goto</span> ENDIF;</span><br><span class="line">do_something;</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>

<p>这里有两个难以预测的分支。如果我们用<code>&amp;</code>而不是<code>&amp;&amp;</code>连接两个条件，我们将：</p>
<ul>
<li>强制同时评估两个条件：<code>&amp;</code>运算符是算术<code>AND</code>运算，并且必须评估两边。</li>
<li>使条件更容易预测，从而降低分支误预测率：两个完全独立的条件（概率为50%）将产生一个联合条件（概率为25%）。</li>
<li>摆脱一个分支：我们将拥有一个更容易预测的分支，而不是原来的两个分支。</li>
</ul>
<p>运算符<code>&amp;</code>评估这两个条件，并且在生成的程序集中将只有一个分支而不是两个。同样的情况也适用于运算符<code>||</code>及其孪生运算符<code>|</code>。<br>请注意：根据C++标准，bool类型的值为0表示false，任何其他值表示true。C++标准保证逻辑运算和算术比较的结果始终为零或一，但不能保证所有布尔值都只有这两个值。您可以通过应用<code>!!</code>来标准化<code>bool</code>变量其上的操作。</p>
<h3 id="3-4-6-向编译器建议哪个分支概率更高"><a href="#3-4-6-向编译器建议哪个分支概率更高" class="headerlink" title="3.4.6. 向编译器建议哪个分支概率更高"></a>3.4.6. 向编译器建议哪个分支概率更高</h3><p>GCC和CLANG提供了关键字，程序员可以使用这些关键字来告诉他们哪些分支具有更高的概率。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x)      __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x)    __builtin_expect(!!(x), 0)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">likely</span>(ptr)) &#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常我们通过可能和不太可能的宏使用<code>__builtin_expect</code>，因为它们的语法在任何地方使用都很麻烦。当这样注释时，编译器将重新排列if和else分支中的指令，以便最优化地使用底层硬件。请确保条件概率正确，否则性能可能会下降。</p>
<h3 id="3-4-7-使用无分支算法"><a href="#3-4-7-使用无分支算法" class="headerlink" title="3.4.7. 使用无分支算法"></a>3.4.7. 使用无分支算法</h3><p>一些用分支表达的算法可以转换为无分支算法。例如，下面的函数<code>abs</code>使用一种技巧来计算数字的绝对值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> mask = a &gt;&gt; <span class="built_in">sizeof</span>(<span class="type">int</span>) * CHAR_BIT - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (a + mask) ^ mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-8-使用条件加载而不是分支"><a href="#3-4-8-使用条件加载而不是分支" class="headerlink" title="3.4.8. 使用条件加载而不是分支"></a>3.4.8. 使用条件加载而不是分支</h3><p>许多CPU支持可用于删除分支的条件移动指令。这是一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以重写为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> new_x = x + <span class="number">1</span>;</span><br><span class="line">x = (x &gt; y) ? new_x : x; <span class="comment">// the compiler should recognize this and emit a conditional branch</span></span><br></pre></td></tr></table></figure>

<p>编译器应该认识到第2行的命令可以写为变量<code>x</code>的条件加载并发出条件移动指令。不幸的是，编译器对于何时发出条件分支有自己的内部逻辑，这并不总是像开发人员所期望的那样。但是，可以使用内联汇编来强制条件加载。</p>
<h3 id="3-4-9-通过算术实现无分支"><a href="#3-4-9-通过算术实现无分支" class="headerlink" title="3.4.9. 通过算术实现无分支"></a>3.4.9. 通过算术实现无分支</h3><p>有一种方法可以通过巧妙地使用算术运算来实现无分支。条件增量示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With branch</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    x += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Branchless</span></span><br><span class="line">x += -(a &gt; b) &amp; y; </span><br></pre></td></tr></table></figure>

<p>在上面的示例中，表达式<code>-(a &gt; b)</code>将创建一个掩码，当条件为假时，该掩码为0；当条件为真时，该掩码全为1。</p>
<p>条件赋值的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With branch</span></span><br><span class="line">x = (a &gt; b) ? val_a : val_b;</span><br><span class="line"><span class="comment">// Branchless</span></span><br><span class="line">x = val_a;</span><br><span class="line">x += -(a &gt; b) &amp; (val_b - val_a);</span><br></pre></td></tr></table></figure>

<p>在循环缓冲区中移动索引的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With branch</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_next_element</span><span class="params">(<span class="type">int</span> current, <span class="type">int</span> buffer_len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (next == buffer_len) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Branchless</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_next_element_branchless</span><span class="params">(<span class="type">int</span> current, <span class="type">int</span> buffer_len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (next &lt; buffer_len) * next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-10-重新组织代码以避免分支"><a href="#3-4-10-重新组织代码以避免分支" class="headerlink" title="3.4.10. 重新组织代码以避免分支"></a>3.4.10. 重新组织代码以避免分支</h3><p>假设您有一个名为<code>animation</code>的类，它可以是可见的也可以是隐藏的。处理可见<code>animation</code>与处理隐藏<code>animation</code>有很大不同。有一个包含名为<code>animation_list</code>的<code>animation</code>的列表，处理如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> animation&amp; a: animation_list) &#123;</span><br><span class="line">    a.<span class="built_in">step_a</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">is_visible</span>()) &#123;</span><br><span class="line">        a.<span class="built_in">step_av</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">step_b</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.is_visible) &#123;</span><br><span class="line">        a.<span class="built_in">step_bv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除非<code>animation</code>根据可见性进行排序，否则分支预测器确实很难处理上述代码。有两种方法可以解决这个问题。一是根据<code>is_visible()</code>对<code>animation_list</code>中的动画进行排序。第二种是创建两个列表，<code>animation_list_visible</code>和<code>animation_list_hidden</code>，并重写代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> animation&amp; a: animation_list_visible) &#123;</span><br><span class="line">    a.<span class="built_in">step_a</span>();</span><br><span class="line">    a.<span class="built_in">step_av</span>();</span><br><span class="line">    a.<span class="built_in">step_b</span>();</span><br><span class="line">    a.<span class="built_in">step_bv</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> animation&amp; a: animation_list_hidden) &#123;</span><br><span class="line">    a.<span class="built_in">step_a</span>();</span><br><span class="line">    a.<span class="built_in">step_b</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的条件都消失了，并且没有分支错误预测。</p>
<h3 id="3-4-11-使用模板删除分支"><a href="#3-4-11-使用模板删除分支" class="headerlink" title="3.4.11. 使用模板删除分支"></a>3.4.11. 使用模板删除分支</h3><p>如果将布尔值传递给函数并且在函数内部将其用作参数，则可以通过将其作为模板参数传递来删除它。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">average</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> len, <span class="type">bool</span> include_negatives)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> average = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (include_negatives) &#123;</span><br><span class="line">            average += array[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                average += array[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (include_negatives) &#123;</span><br><span class="line">         <span class="keyword">return</span> average / len;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> average / count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此函数中，可以多次评估<code>include_negatives</code>的条件。要删除评估，请将参数作为模板参数而不是函数参数传递。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> include_negatives&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">average</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> average = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (include_negatives) &#123;</span><br><span class="line">            average += array[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                average += array[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (include_negatives) &#123;</span><br><span class="line">         <span class="keyword">return</span> average / len;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> average / count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过此实现，编译器将生成该函数的两个版本，一种带有<code>include_negatives</code>，一种不带有<code>include_negatives</code>（以防调用此参数具有不同值的函数）。分支完全消失了，未使用的分支中的代码也消失了。</p>
<p>但现在需要以不同的方式调用您的函数。所以会这样称呼它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> avg;</span><br><span class="line"><span class="type">bool</span> should_include_negatives = <span class="built_in">get_should_include_negatives</span>();</span><br><span class="line"><span class="keyword">if</span> (should_include_negatives) &#123;</span><br><span class="line">    avg = <span class="built_in">average</span>&lt;<span class="literal">true</span>&gt;(array, len);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    avg = <span class="built_in">average</span>&lt;<span class="literal">false</span>&gt;(array, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这实际上是一种称为<code>branch optimization</code>的编译器优化。如果<code>include_negatives</code>的值在编译时已知并且编译器决定内联函数平均值，它将删除分支和未使用的代码。然而，带有模板的版本保证了这一点，而原始版本则不然。</p>
<p>编译器通常可以进行这种优化。如果编译器可以保证值<code>include_negatives</code>在循环执行期间不会更改其值，则它可以创建两个版本的循环：一种用于其值为<code>true</code>的情况，另一种用于其值为<code>false</code>的情况。这种优化称为循环不变代码优化。</p>
<h3 id="3-4-12-避免分支的其他一些技巧"><a href="#3-4-12-避免分支的其他一些技巧" class="headerlink" title="3.4.12. 避免分支的其他一些技巧"></a>3.4.12. 避免分支的其他一些技巧</h3><p>如果在代码中多次检查不可更改的条件，则通过检查一次然后进行一些代码复制可能会获得更好的性能。因此，在下面的示例中，两个分支可以替换为一个分支。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_visible) &#123;</span><br><span class="line">    <span class="built_in">hide</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">process</span>();</span><br><span class="line"><span class="keyword">if</span> (is_visible) &#123;</span><br><span class="line">    <span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以替换为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_visible) &#123;</span><br><span class="line">    <span class="built_in">hide</span>();</span><br><span class="line">    <span class="built_in">process</span>();</span><br><span class="line">    <span class="built_in">display</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以引入一个两元素数组，一个用于在条件为<code>true</code>时保存结果，另一个用于在条件为<code>false</code>时保存结果。一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> larger = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; m) &#123;</span><br><span class="line">        larger++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> larger;</span><br></pre></td></tr></table></figure>

<p>可以替换为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result[] = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result[a&gt;i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h2 id="3-5-实验"><a href="#3-5-实验" class="headerlink" title="3.5. 实验"></a>3.5. 实验</h2><p>作者在“AMD A8-4500M quad-core x86-64” ，“Allwinner sun7i A20 dual-core ARMv7”和“Ingenic JZ4780 dual-core MIPS32r2”三种处理器上进行了多组对照试验，具体细节暂不描述，结论如下：</p>
<p>分支推测打破了一些数据依赖性，并有效地掩盖了CPU需要等待内存数据的时间。如果分支预测器的猜测是正确的，那么当数据从内存到达时，很多工作就已经完成了。对于无分支的代码来说，情况并非如此。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">1. 参考文章</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">2. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%AF%A6%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text">3. 详述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-CPU%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. CPU相关的知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-CPU%E5%A4%84%E7%90%86%E5%88%86%E6%94%AF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. CPU处理分支的几种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%88%86%E6%94%AF%E5%AF%B9%E4%BA%8E%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. 分支对于性能的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%88%86%E6%94%AF%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. 分支优化手段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E4%BC%98%E5%8C%96%E8%BF%9E%E6%8E%A5%E6%9D%A1%E4%BB%B6%EF%BC%88join-condition%EF%BC%89"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1. 优化连接条件（join condition）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E4%BC%98%E5%8C%96if-else%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2. 优化if&#x2F;else结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8%E6%9B%BF%E6%8D%A2switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3. 使用查找表替换switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E5%B0%86%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E6%83%85%E5%86%B5%E7%A7%BB%E5%87%BAswitch%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.4.4.</span> <span class="toc-text">3.4.4. 将最常见的情况移出switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-%E9%87%8D%E5%86%99%E8%BF%9E%E6%8E%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.4.5.</span> <span class="toc-text">3.4.5. 重写连接条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-6-%E5%90%91%E7%BC%96%E8%AF%91%E5%99%A8%E5%BB%BA%E8%AE%AE%E5%93%AA%E4%B8%AA%E5%88%86%E6%94%AF%E6%A6%82%E7%8E%87%E6%9B%B4%E9%AB%98"><span class="toc-number">3.4.6.</span> <span class="toc-text">3.4.6. 向编译器建议哪个分支概率更高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-7-%E4%BD%BF%E7%94%A8%E6%97%A0%E5%88%86%E6%94%AF%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.7.</span> <span class="toc-text">3.4.7. 使用无分支算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-8-%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%80%8C%E4%B8%8D%E6%98%AF%E5%88%86%E6%94%AF"><span class="toc-number">3.4.8.</span> <span class="toc-text">3.4.8. 使用条件加载而不是分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-9-%E9%80%9A%E8%BF%87%E7%AE%97%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%88%86%E6%94%AF"><span class="toc-number">3.4.9.</span> <span class="toc-text">3.4.9. 通过算术实现无分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-10-%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81%E4%BB%A5%E9%81%BF%E5%85%8D%E5%88%86%E6%94%AF"><span class="toc-number">3.4.10.</span> <span class="toc-text">3.4.10. 重新组织代码以避免分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-11-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF"><span class="toc-number">3.4.11.</span> <span class="toc-text">3.4.11. 使用模板删除分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-12-%E9%81%BF%E5%85%8D%E5%88%86%E6%94%AF%E7%9A%84%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7"><span class="toc-number">3.4.12.</span> <span class="toc-text">3.4.12. 避免分支的其他一些技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.5.</span> <span class="toc-text">3.5. 实验</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://cakgod.github.io/2022/10/07/branch-and-optimization/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&text=分支对性能的影响以及分支优化"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&title=分支对性能的影响以及分支优化"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&is_video=false&description=分支对性能的影响以及分支优化"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=分支对性能的影响以及分支优化&body=Check out this article: http://cakgod.github.io/2022/10/07/branch-and-optimization/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&title=分支对性能的影响以及分支优化"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&title=分支对性能的影响以及分支优化"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&title=分支对性能的影响以及分支优化"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&title=分支对性能的影响以及分支优化"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://cakgod.github.io/2022/10/07/branch-and-optimization/&name=分支对性能的影响以及分支优化&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://cakgod.github.io/2022/10/07/branch-and-optimization/&t=分支对性能的影响以及分支优化"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    CAKGOD
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>
