<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>智能指针</title>
      <link href="/2023/10/08/smart-pointer/"/>
      <url>/2023/10/08/smart-pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在实际的C++开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p><ul><li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li><li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li><li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li></ul><p>C++98&#x2F;03标准中，支持使用<code>auto_ptr</code>智能指针来实现堆内存的自动回收；C++11新标准在废弃<code>auto_ptr</code>的同时，增添了<code>unique_ptr</code>、<code>shared_ptr</code>以及<code>weak_ptr</code>这3个智能指针来实现堆内存的自动回收。</p><p>C++智能指针底层是采用引用计数的方式实现的。简单理解，智能指针在申请堆内存空间的同时，会为其配备一个整型值（初始值为1），每当有新对象使用此堆内存时，该整形值加1；反之，每当使用此堆内存的对象被释放时，该整型值减1。当堆空间对应的整型值为0时，即表明不再有对象使用它，该堆空间就会被释放掉。</p><p>下面介绍三种智能指针，注意：每种智能指针都是以类模板的方式实现的，定义位于<code>&lt;memory&gt;</code>头文件，并位于<code>std</code>命名空&gt;间中，因此在使用该类型指针时，程序中应包含如下2行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h1 id="2-shared-ptr"><a href="#2-shared-ptr" class="headerlink" title="2. shared_ptr"></a>2. shared_ptr</h1><p>和<code>unique_ptr</code>、<code>weak_ptr</code>不同之处在于，多个<code>shared_ptr</code>智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个shared_ptr&#96;指针放弃了堆内存的“使用权”（引用计数减1），也不会影响其他指向同一堆内存的shared_ptr指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p><h2 id="2-1-创建"><a href="#2-1-创建" class="headerlink" title="2.1. 创建"></a>2.1. 创建</h2><p>介绍一下几种创建方式：</p><p>（1）创建空智能指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1;             <span class="comment">// 不传入任何实参</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;    <span class="comment">// 传入空指针nullptr</span></span><br></pre></td></tr></table></figure><p>注意，空的<code>shared_ptr</code>指针，其初始引用计数为0，而不是1。</p><p>（2）创建非空<code>shared_ptr</code>智能指针，明确其指向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>这样就成功构建了一个<code>shared_ptr</code>智能指针，其指向一块存有10个int类型数据的堆内存空间。</p><p>同时，C++11标准中还提供了<code>std::make_shared&lt;T&gt;</code>模板函数，其可以用于初始化<code>shared_ptr</code>智能指针，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>以上2种方式创建的p3是完全相同。</p><p>（3）拷贝构造和移动构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p4 = p3;</span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p5 = std::<span class="built_in">move</span>(p4);</span><br></pre></td></tr></table></figure><p>如上所示，p3和p4都是<code>shared_ptr</code>类型的智能指针，因此可以用p3来初始化p4，由于p3是左值，因此会调用拷贝构造函数。需要注意的是，如果p3为空智能指针，则p4也为空智能指针，其引用计数初始值为0；反之，则表明p4和p3指向同一块堆内存，同时该堆空间的引用计数会加1。</p><p>而对于<code>std::move(p4)</code>来说，该函数会强制将p4转换成对应的右值，因此初始化p5调用的是移动构造函数。另外和调用拷贝构造函数不同，用<code>std::move(p4)</code>初始化p5，会使得p5拥有了p4的堆内存，而p4则变成了空智能指针。</p><p>注意，同一普通指针不能同时为多个<code>shared_ptr</code>对象赋值，否则会导致程序发生异常。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h2 id="2-2-释放"><a href="#2-2-释放" class="headerlink" title="2.2. 释放"></a>2.2. 释放</h2><p>再介绍一下<code>shared_ptr</code>的自定义释放规则，在初始化时可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为0时，会优先调用自定义的释放规则。在某些场景中，自定义释放规则是很有必要的。比如，对于申请的动态数组来说，<code>shared_ptr</code>指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。</p><p>对于申请的动态数组，释放规则可以使用C++11标准中提供的<code>default_delete&lt;T&gt;</code>模板类，也可以自定义释放规则：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定 default_delete 作为释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义释放规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteInt</span><span class="params">(<span class="type">int</span>*p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化智能指针，并自定义释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], deleteInt)</span></span>;</span><br></pre></td></tr></table></figure><p>借助lambda表达式，还可以像如下这样初始化p7：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123; <span class="keyword">delete</span> []p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3. 方法"></a>2.3. 方法</h2><p>总结一下<code>shared_ptr</code>的成员方法：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td><code>operator=()</code></td><td>重载赋值号，使得同一类型的<code>shared_ptr</code>智能指针可以相互赋值。</td></tr><tr><td><code>operator*()</code></td><td>重载<code>*</code>号，获取当前<code>shared_ptr</code>智能指针对象指向的数据。</td></tr><tr><td><code>operator-&gt;()</code></td><td>重载<code>-&gt;</code>号，当智能指针指向的数据类型为自定义的结构体时，通过<code>-&gt;</code>运算符可以获取其内部的指定成员。</td></tr><tr><td><code>swap()</code></td><td>交换2个相同类型<code>shared_ptr</code>智能指针的内容。</td></tr><tr><td><code>reset()</code></td><td>当函数没有实参时，该函数会使当前<code>shared_ptr</code>所指堆内存的引用计数减1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的<code>shared_ptr</code>对象会获得该存储空间的所有权，并且引用计数的初始值为1。</td></tr><tr><td><code>get()</code></td><td>获得<code>shared_ptr</code>对象内部包含的普通指针。</td></tr><tr><td><code>use_count()</code></td><td>返回同当前<code>shared_ptr</code>对象（包括它）指向相同的所有<code>shared_ptr</code>对象的数量。</td></tr><tr><td><code>unique()</code></td><td>判断当前<code>shared_ptr</code>对象指向的堆内存，是否不再有其它<code>shared_ptr</code>对象再指向它。</td></tr><tr><td><code>operator bool()</code></td><td>判断当前<code>shared_ptr</code>对象是否为空智能指针，如果是空指针，返回false；反之，返回true。</td></tr></tbody></table><h1 id="3-unique-ptr"><a href="#3-unique-ptr" class="headerlink" title="3. unique_ptr"></a>3. unique_ptr</h1><p>作为智能指针的一种，<code>unique_ptr</code>指针也具备“在适当时机自动释放堆内存空间”的能力。和<code>shared_ptr</code>指针最大的不同之处在于，<code>unique_ptr</code>指针指向的堆内存无法同其它<code>unique_ptr</code>共享，也就是说，每个<code>unique_ptr</code>指针都独自拥有对其所指堆内存空间的所有权。</p><p>这也就意味着，每个<code>unique_ptr</code>指针指向的堆内存空间的引用计数，都只能为1，一旦该<code>unique_ptr</code>指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。</p><h2 id="3-1-创建"><a href="#3-1-创建" class="headerlink" title="3.1. 创建"></a>3.1. 创建</h2><p>（1）创建空<code>unique_ptr</code>指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>（2）创建非空<code>unique_ptr</code>指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>（3）移动构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(p4)</span></span>;<span class="comment">//错误，堆内存不共享</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>;<span class="comment">//正确，调用移动构造函数</span></span><br></pre></td></tr></table></figure><h2 id="3-2-释放"><a href="#3-2-释放" class="headerlink" title="3.2. 释放"></a>3.2. 释放</h2><p>默认情况下，<code>unique_ptr</code>指针采用<code>std::default_delete&lt;T&gt;</code>方法释放堆内存。当然，我们也可以自定义符合实际场景的释放规则。值得一提的是，和<code>shared_ptr</code>指针不同，为<code>unique_ptr</code>自定义释放规则，只能采用函数对象的方式。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的释放规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myDel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>, myDel&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//std::unique_ptr&lt;int, myDel&gt; p6(new int, myDel());</span></span><br></pre></td></tr></table></figure><h2 id="3-3-方法"><a href="#3-3-方法" class="headerlink" title="3.3. 方法"></a>3.3. 方法</h2><p>总结一下<code>unique_ptr</code>的成员方法：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td><code>operator=()</code></td><td>重载赋值号，从而可以将nullptr或者一个右值<code>unique_ptr</code>指针直接赋值给当前同类型的<code>unique_ptr</code>指针。</td></tr><tr><td><code>operator*()</code></td><td>重载<code>*</code>号，获取当前<code>unique_ptr</code>智能指针对象指向的数据。</td></tr><tr><td><code>operator-&gt;()</code></td><td>重载<code>-&gt;</code>号，当智能指针指向的数据类型为自定义的结构体时，通过<code>-&gt;</code>运算符可以获取其内部的指定成员。</td></tr><tr><td><code>operator[]()</code></td><td>重载<code>[]</code>号，当<code>unique_ptr</code>指针指向一个数组时，可以直接通过<code>[]</code>获取指定下标位置处的数据。</td></tr><tr><td><code>swap(x)</code></td><td>交换当前<code>unique_ptr</code>指针和同类型的<code>x</code>指针。</td></tr><tr><td><code>reset(p)</code></td><td>其中p表示一个普通指针，如果p为nullptr，则当前<code>unique_ptr</code>也变成空指针；反之，则该函数会释放当前<code>unique_ptr</code>指针指向的堆内存（如果有），然后获取<code>p</code>所指堆内存的所有权（p为nullptr）。</td></tr><tr><td><code>get()</code></td><td>获得<code>unique_ptr</code>对象内部包含的普通指针。</td></tr><tr><td><code>get_deleter()</code></td><td>获取当前<code>unique_ptr</code>指针释放堆内存空间所用的规则。</td></tr><tr><td><code>release()</code></td><td>释放当前<code>unique_ptr</code>指针对所指堆内存的所有权，但该存储空间并不会被销毁。</td></tr><tr><td><code>operator bool()</code></td><td><code>unique_ptr</code>指针可直接作为<code>if</code>语句的判断条件，以判断该指针是否为空，如果为空，则为false；反之为true。</td></tr></tbody></table><h1 id="4-weak-ptr"><a href="#4-weak-ptr" class="headerlink" title="4. weak_ptr"></a>4. weak_ptr</h1><p>C++11标准虽然将<code>weak_ptr</code>定位为智能指针的一种，但该类型指针通常不单独使用（没有实际用处），只能和<code>shared_ptr</code>类型指针搭配使用。甚至于，我们可以将<code>weak_ptr</code>类型指针视为<code>shared_ptr</code>指针的一种辅助工具，借助<code>weak_ptr</code>类型指针，我们可以获取<code>shared_ptr</code>指针的一些状态信息，比如有多少指向相同的<code>shared_ptr</code>指针、<code>shared_ptr</code>指针指向的堆内存是否已经被释放等等。</p><p>需要注意的是，当<code>weak_ptr</code>类型指针的指向和某一<code>shared_ptr</code>指针相同时，<code>weak_ptr</code>指针并不会使所指堆内存的引用计数加1；同样，当<code>weak_ptr</code>指针被释放时，之前所指堆内存的引用计数也不会因此而减1。也就是说，<code>weak_ptr</code>类型指针并不会影响所指堆内存空间的引用计数。</p><p>除此之外，<code>weak_ptr&lt;T&gt;</code>模板类中没有重载<code>*</code>和<code>-&gt;</code>运算符，这也就意味着，<code>weak_ptr</code>类型指针只能访问所指的堆内存，而无法修改它。</p><h2 id="4-1-创建"><a href="#4-1-创建" class="headerlink" title="4.1. 创建"></a>4.1. 创建</h2><p>（1）创建空<code>weak_ptr</code>指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br></pre></td></tr></table></figure><p>（2）根据已有<code>weak_ptr</code>指针创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span> <span class="params">(wp1)</span></span>;</span><br></pre></td></tr></table></figure><p>（3）根据已有<code>shared_ptr</code>指针创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span> <span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span> <span class="params">(sp)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2. 方法"></a>4.2. 方法</h2><p>总结一下<code>weak_ptr</code>的成员方法：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td><code>operator=()</code></td><td>重载赋值号，使得<code>weak_ptr</code>指针可以直接被<code>weak_ptr</code>或者<code>shared_ptr</code>类型指针赋值。</td></tr><tr><td><code>swap(x)</code></td><td>其中<code>x</code>表示一个同类型的<code>weak_ptr</code>类型指针，该函数可以互换2个同类型<code>weak_ptr</code>指针的内容。</td></tr><tr><td><code>reset()</code></td><td>将当前 weak_ptr 指针置为空指针。</td></tr><tr><td><code>use_count()</code></td><td>查看指向和当前<code>weak_ptr</code>指针相同的<code>shared_ptr</code>指针的数量。</td></tr><tr><td><code>expired()</code></td><td>判断当前<code>weak_ptr</code>指针为否过期（指针为空，或者指向的堆内存已经被释放）。</td></tr><tr><td><code>lock()</code></td><td>如果当前<code>weak_ptr</code>已经过期，则该函数会返回一个空的<code>shared_ptr</code>指针；反之，该函数返回一个和当前<code>weak_ptr</code>指向相同的<code>shared_ptr</code>指针。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的网站</title>
      <link href="/2023/09/28/interesting-website/"/>
      <url>/2023/09/28/interesting-website/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>记录一些有趣的网站、工具或者文章。这些信息来源比较广泛，有些比较实用的也许会单独拆出来另外写一篇，有些不太实用（比如waiting list，WIP，搞怪等）的会先放在这里。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><ul><li>阮一峰大神的分享：<a href="https://github.com/ruanyf/weekly">科技爱好者周刊</a></li><li>其他</li></ul><h1 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h1><h2 id="1-AI应用"><a href="#1-AI应用" class="headerlink" title="1. AI应用"></a>1. AI应用</h2><h3 id="1-网页生成"><a href="#1-网页生成" class="headerlink" title="(1) 网页生成"></a>(1) 网页生成</h3><ul><li><a href="https://v0.dev/">v0</a> （waiting list）Vercel推出的一个实验性产品，使用AI生成网页。输入对页面需求的文字描述，会给出UI设计。应该是目前最强的AI网页生成器。</li></ul><h3 id="2-财经"><a href="#2-财经" class="headerlink" title="(2) 财经"></a>(2) 财经</h3><ul><li><a href="https://finchat.io/">findchat</a> AI财报分析，可以解析上市公司财报（包含美股、港股、沪深A股），并支持对财报内容提问。</li><li><a href="https://beebee.ai/">beebee</a> 与findchat功能类似</li></ul><h3 id="3-搜索"><a href="#3-搜索" class="headerlink" title="(3) 搜索"></a>(3) 搜索</h3><ul><li><a href="https://cn.noteai.com/">noteai</a> 用户在该网站输入问题，它会用AI从搜索引擎返回的网页结果里面，总结出答案。</li><li></li></ul><h3 id="4-语音"><a href="#4-语音" class="headerlink" title="(4) 语音"></a>(4) 语音</h3><ul><li><a href="https://huggingface.co/spaces/Xenova/whisper-web">whisper</a> 将英语音频转成文本的在线工具。</li></ul><h3 id="5-图像"><a href="#5-图像" class="headerlink" title="(5) 图像"></a>(5) 图像</h3><ul><li><a href="https://www.stablediffusionai.ai/">SDXL</a> SDXL是Stable Diffusion最新发布的画图模型。这是网友架设的体验站，不需要登陆也不需要付费，直接体验文生图。</li><li><a href="https://huggingface.co/spaces/jbilcke-hf/comic-factory">漫画工厂</a> 一个AI引擎，输入剧情自动产生多种风格漫画（日式、美式等等）。</li><li><a href="https://huggingface.co/spaces/akhaliq/AnimeGANv2">animeganv2</a> 输入一张图片，将其转化为漫画风。</li></ul><h3 id="6-资源"><a href="#6-资源" class="headerlink" title="(6) 资源"></a>(6) 资源</h3><ul><li><a href="https://www.aihub.cn/">AIHUB</a> 该网站收集各种AI工具和资源。</li><li><a href="https://codenews.cc/chatgpt">CHATGPT可用网站</a> ChatGPT的使用页面，并且收集了相关资源。</li><li><a href="https://xinghuo.xfyun.cn/">讯飞星火认知大模型</a></li><li><a href="https://github.com/luban-agi/Awesome-Domain-LLM">Awesome Domain LLM</a> 这个仓库收集各种垂直领域的大语言模型。</li><li><a href="https://chathub.gg/?utm_source=github">allinone插件</a> 一个界面内使用所有chatgpt，当然需要账号登陆才行。</li><li><a href="https://ai.dreamthere.cn/">aidreamthere</a> 该网站收集了各种AI站点，并进行了分类。</li><li><a href="https://github.com/luban-agi/Awesome-AIGC-Tutorials">AIGC</a> 收集各种生成式AI的教程。</li></ul><h3 id="7-股票"><a href="#7-股票" class="headerlink" title="(7) 股票"></a>(7) 股票</h3><ul><li><a href="https://stockai.trade/">stockai.trade</a> 利用GPT进行AI选股。</li></ul><h3 id="8-作文批改"><a href="#8-作文批改" class="headerlink" title="(8) 作文批改"></a>(8) 作文批改</h3><ul><li><a href="https://www.essay.art/ielts">essay.art</a> 使用GPT4对雅思作文和托福作文判分和批改。</li></ul><h3 id="9-聊天"><a href="#9-聊天" class="headerlink" title="(9) 聊天"></a>(9) 聊天</h3><ul><li><a href="https://kagi.com/fastgpt">kagi</a> 一个简易的聊天工具。</li><li><a href="https://www.prettypolly.app/app">PrettyPolly</a> 与AI进行口语练习。</li></ul><h3 id="10-代码生成"><a href="#10-代码生成" class="headerlink" title="(10) 代码生成"></a>(10) 代码生成</h3><ul><li><a href="https://aicodeconvert.com/">AICODETRANSLATOR</a> 该网站可以将一种语言的程序，转换成另一种语言。用户也可以描述想要什么程序，它来生成代码。</li><li><a href="https://www.docstring.ai/">docstring</a> 输入一段代码，给出这段代码的注释，支持多种程序语言。</li></ul><h3 id="11-其他"><a href="#11-其他" class="headerlink" title="(11) 其他"></a>(11) 其他</h3><ul><li><a href="https://www.namedbyai.com/">AI取名</a></li><li></li></ul><h2 id="2-计算"><a href="#2-计算" class="headerlink" title="2. 计算"></a>2. 计算</h2><ul><li><a href="https://zh.numberempire.com/">多功能计算器</a> 提供了很多实用的计算器功能。 </li><li><a href="https://www.gigacalculator.com/calculators/statistics/">统计计算器</a> 提供了很多统计相关的计算器功能。</li><li><a href="https://www.wolframalpha.com/">wolframalpha</a> 提供了非常多的自动化问题解决功能，它的工作原理是利用其大量的专家级知识和算法来自动回答问题、进行分析并生成报告。</li></ul><h2 id="3-IP归属地查询"><a href="#3-IP归属地查询" class="headerlink" title="3. IP归属地查询"></a>3. IP归属地查询</h2><ul><li><a href="https://ipinfo.io/">IPINFO</a></li><li><a href="https://ipapi.is/">IPAPI</a></li></ul><h2 id="4-PDF处理"><a href="#4-PDF处理" class="headerlink" title="4. PDF处理"></a>4. PDF处理</h2><ul><li><a href="https://github.com/docusealco/docuseal">docuseal</a> PDF签名</li><li><a href="https://ocrmypdf.readthedocs.io/en/latest/index.html">ocrmypdf</a> PDF ocr工具。</li></ul><h2 id="5-图片处理"><a href="#5-图片处理" class="headerlink" title="5. 图片处理"></a>5. 图片处理</h2><ul><li><a href="https://github.com/zhbhun/idify">IDIFY</a> 将上传的用户照片转为证件照。</li><li><a href="https://github.com/palxiao/poster-design">迅排</a> 开源的在线图片设计器。</li><li><a href="https://github.com/TencentARC/GFPGAN">GFPGAN</a> 开源的老照片修复。</li><li><a href="https://bgsub.cn/">BGSUB</a> 替换照片背景</li><li><a href="https://dunin.itch.io/ptop">paint-of-persia</a> 一款动态像素艺术工具。</li></ul><h2 id="6-资源-1"><a href="#6-资源-1" class="headerlink" title="6. 资源"></a>6. 资源</h2><ul><li><a href="https://github.com/krahets/hello-algo">Hello算法</a> 一本开源的中文电子书籍，介绍数据结构与算法，配有动画图解。</li><li><a href="https://wesmckinney.com/book/">Python数据分析</a></li><li><a href="https://www.deusinmachina.net/p/the-basics-of-arm64-assembly">ARM64汇编语言入门教程</a></li><li><a href="https://makefiletutorial.com/">MakeFile学习</a></li><li><a href="https://github.com/lovefc/china_school_badge">高校校徽字体图标库</a></li><li><a href="https://icongo.github.io/#/">icon</a> 查找图标。</li></ul><h2 id="7-图标"><a href="#7-图标" class="headerlink" title="7. 图标"></a>7. 图标</h2><ul><li><a href="https://yesicon.app/">yesicon</a> 中文的图标搜索引擎，作者利用ChatGPT翻译了Iconify的18万个图标名。</li></ul><h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h2><ul><li><a href="https://krikienoid.github.io/flagwaver/">flagwaver</a> 提供一张图片，可以是网址或者本地文件，会造出旗子飘动的效果。</li><li><a href="https://gifcities.org/">gif收集</a> 这个网站收集了很多gif，支持搜索。</li><li><a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">floatconverter</a> 浮点数在线转换。</li><li><a href="https://tooltt.com/floatconverter/">floatconverter1</a> 又一个浮点数在线转换。</li><li><a href="http://binary-converter.bchrt.com/">floatconverter2</a> 又又一个浮点数在线转换。</li><li><a href="http://www.speedfly.cn/tools/hexconvert/">converter</a> 在线进制转换。</li><li><a href="https://www.haomeili.net/Math/RenYiJinZhiZhuanHuan?From=64&FromBase=64&To=6G&ToBase=62">converter1</a> 又一个在线进制转换。</li><li><a href="https://tool.oschina.net/hexconvert/">converter2</a> 又又一个在线进制转换。</li><li><a href="https://www.toolhelper.cn/">toolhelper</a> 有很多比较实用的在线工具。</li><li><a href="https://evanw.github.io/float-toy/">float-toy</a> 以图片的方式展示浮点进制。</li><li><a href="https://www.jq22.com/textDifference">diff</a> 在线文本比较工具。</li><li><a href="https://www.67tool.com/">67tool</a> 有很多比较实用的在线工具。</li><li><a href="https://setpose.com/">setpose</a> 人体姿势模拟器。</li><li><a href="https://getsimnum.caict.ac.cn/#/">电话卡查询</a> 查询自己名下有多少张电话卡。</li><li><a href="https://pimeyes.com/en">face</a> 查询网络图片出处。</li><li><a href="https://yunmaovideo.com/">yunmao</a> 在线转码工具。</li></ul><h2 id="9-聊天-1"><a href="#9-聊天-1" class="headerlink" title="9. 聊天"></a>9. 聊天</h2><ul><li><a href="https://github.com/vasanthv/talk">talk</a> 一个开源的网页聊天工具，非常轻量化。</li></ul><h2 id="10-文章"><a href="#10-文章" class="headerlink" title="10. 文章"></a>10. 文章</h2><ul><li><a href="https://androidblog.a.pinggy.io/">将网站托管在手机上</a></li><li><a href="https://engineering.desmos.com/articles/pratt-parser/">编译器如何解析</a></li></ul><h2 id="11-语言编译器"><a href="#11-语言编译器" class="headerlink" title="11. 语言编译器"></a>11. 语言编译器</h2><ul><li><a href="https://www.jdoodle.com/python3-programming-online/">PYTHON IDE0</a></li><li><a href="https://www.python.org/shell/">PYTHON IDE1</a></li><li><a href="https://c.runoob.com/compile/12/">多语言IDE</a></li><li><a href="https://vscode.dev/">VSCODE在线</a></li><li><a href="https://github.dev/github/dev">VSCODE在线1</a></li><li><a href="https://dexter.uwplse.org/">dexter</a> 将c++代码自动转换为halide代码。</li></ul><h2 id="12-绘图"><a href="#12-绘图" class="headerlink" title="12. 绘图"></a>12. 绘图</h2><ul><li><a href="https://app.diagrams.net/">diagrams</a></li><li><a href="https://pddon.com/">pddon</a> 一个免费的在线绘图软件。</li><li><a href="https://www.composable.art/app">composable</a> 一个在线3D绘图软件。</li></ul><h2 id="13-专利"><a href="#13-专利" class="headerlink" title="13. 专利"></a>13. 专利</h2><ul><li><a href="https://pss-system.cponline.cnipa.gov.cn/conventionalSearch">search</a> 专利检索。</li></ul><h2 id="14-社工库"><a href="#14-社工库" class="headerlink" title="14. 社工库"></a>14. 社工库</h2><ul><li><a href="https://zy.xywlapi.cc/">xapi</a></li><li><a href="https://loseprivacy.net/?lp=MjU0ODg1">loseprivacy</a> 泄露数据查询。</li></ul><h2 id="15-文章"><a href="#15-文章" class="headerlink" title="15. 文章"></a>15. 文章</h2><ul><li><a href="https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign">去分支算法</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 闲杂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代微处理器</title>
      <link href="/2023/01/07/modern-microprocessor/"/>
      <url>/2023/01/07/modern-microprocessor/</url>
      
        <content type="html"><![CDATA[<h1 id="1-参考文章"><a href="#1-参考文章" class="headerlink" title="1. 参考文章"></a>1. 参考文章</h1><p><a href="https://www.lighterra.com/papers/modernmicroprocessors/">Modern Microprocessors. A 90-Minute Guide!</a></p><p>本文绝对是一篇非常好的文章，以本人的垃圾水平暂时只能读懂部分，并且有点看不下去，先挖个坑。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分支对性能的影响以及分支优化</title>
      <link href="/2022/10/07/branch-and-optimization/"/>
      <url>/2022/10/07/branch-and-optimization/</url>
      
        <content type="html"><![CDATA[<h1 id="1-参考文章"><a href="#1-参考文章" class="headerlink" title="1. 参考文章"></a>1. 参考文章</h1><p><a href="https://johnnysswlab.com/how-branches-influence-the-performance-of-your-code-and-what-can-you-do-about-it/">How branches influence the performance of your code and what can you do about it?</a></p><h1 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h1><p>本文属于上述参考文章的一篇读后感，该文章讲了一些关于分支对于软件性能的影响，以及如何通过优化代码中的分支来提高性能。因为之前的工作中也涉及到类似的工作，顺路在这里重新学习并总结一下。</p><h1 id="3-详述"><a href="#3-详述" class="headerlink" title="3. 详述"></a>3. 详述</h1><p>分支（branch，jump）是非常常见的指令类型之一。根据统计，平均每五条指令就要遇到一条分支指令。对于CPU来说，有效的分支实现对于良好的性能至关重要。</p><h2 id="3-1-CPU相关的知识"><a href="#3-1-CPU相关的知识" class="headerlink" title="3.1. CPU相关的知识"></a>3.1. CPU相关的知识</h2><p>许多现代处理器（但不是全部，特别是嵌入式系统中使用的一些处理器）都具有以下部分或全部功能： </p><ul><li><p><em>流水线（pipeline）</em>：流水线允许CPU同时执行多条指令。CPU将每条指令的执行分为几个阶段，并且每条指令处于不同的执行阶段。汽车工厂也采用同样的原理：在任何给定时间，工厂同时生产五十辆汽车，例如，一辆汽车正在喷漆，另一辆汽车正在安装发动机，第三辆汽车正在安装车灯，流水线可以很短，只有几个阶段（例如三个阶段），也可以很长，有很多阶段（例如二十个阶段）。</p></li><li><p><em>乱序执行（OOE，out of order exexcution）</em>：从程序员的角度来看，程序运行一条又一条指令。在CPU中情况看起来完全不同：CPU不需要按照指令在内存中出现的顺序来执行它们。在执行过程中，一些指令会被阻塞在CPU中等待来自内存的数据或者等待来自其他指令的数据。CPU可以向前看并执行稍后出现但不会被阻塞的指令。当被阻止的指令的数据变得可用时，之前未被阻止的指令已经完成。这可以节省CPU指令执行周期。</p></li><li><p><em>推断执行（speculative exexcution）</em>：即使不能100%确定需要执行指令，CPU也可以开始执行指令。例如，它会猜测条件分支指令的目的地，然后在100%确定会采用分支之前开始执行分支目的地的指令。如果后来CPU发现猜测（推断）是错误的，它将取消推断执行指令的结果，并且一切都将显示为没有进行任何推断。</p></li><li><p><em>分支预测（branch prediction）</em>：现代CPU具有特殊电路，每个分支指令都会记住其先前的结果：采用分支或未采用分支。当下次执行相同的分支指令时，CPU将使用该信息来猜测分支的目的地，然后在分支目的地开始推断执行指令。如果分支预测器正确，这将导致性能加速。</p></li></ul><p>所有现代处理器都具有pipeline，以便更好地利用CPU资源。并大多数都有分支预测和推断执行。就乱序执行而言，大多数低端低功耗处理器不具备此功能，因为它消耗大量电量且速度提升并不大。</p><h2 id="3-2-CPU处理分支的几种方法"><a href="#3-2-CPU处理分支的几种方法" class="headerlink" title="3.2. CPU处理分支的几种方法"></a>3.2. CPU处理分支的几种方法</h2><p>当分支指令进入处理器流水线时，在对其进行解码并计算其目的地之前，分支目的地是未知的。分支指令之后的指令可以是：直接跟随分支的指令或分支目的地处的指令。CPU对于分支指令的处理可以有三种方式：</p><ul><li><p><em>暂停流水线（pause pipeline，stall pipeline）</em>：暂停流水线并停止解码指令，直到分支指令被解码并且知道分支目的地。然后它可以使用正确的指令恢复加载流水线。</p></li><li><p>加载紧随分支之后的指令。万一后来发现这是错误的选择，处理器将需要刷新流水线并开始从分支目的地加载正确的指令。 </p></li><li><p>询问分支预测器是否应该加载紧接在分支之后的指令或分支目的地处的指令。分支预测器还需要告诉流水线分支目的地在哪里（否则将新指令加载到流水线中并将需要等待流水线解析分支目的地）。</p></li></ul><p>采用第一种方式的处理器现在很少见，除了一些非常低端的嵌入式处理器，仅仅让处理器什么都不做就是浪费资源。因此大多数处理器会执行采用第二种方式，常见于低端嵌入式系统和低功耗处理器。采用第三种方式的处理器是常见的台式机和笔记本电脑CPU以及高性能CPU。</p><h2 id="3-3-分支对于性能的影响"><a href="#3-3-分支对于性能的影响" class="headerlink" title="3.3. 分支对于性能的影响"></a>3.3. 分支对于性能的影响</h2><p>主要介绍以下两点影响：</p><ul><li><p>在某些处理器上，指令自上而下“贯穿”（fall through）的开销远远小于分支指令的开销。</p></li><li><p>自动向量化（auto vectorization）是现代处理器中比较常用的提高性能的手段，分支的加入通常导致代码无法向量化。</p></li></ul><h2 id="3-4-分支优化手段"><a href="#3-4-分支优化手段" class="headerlink" title="3.4. 分支优化手段"></a>3.4. 分支优化手段</h2><p>本文重点不在于介绍分支预测，而是较少如何优化代码达到去分支或减少分支来提高软件性能。</p><h3 id="3-4-1-优化连接条件（join-condition）"><a href="#3-4-1-优化连接条件（join-condition）" class="headerlink" title="3.4.1. 优化连接条件（join condition）"></a>3.4.1. 优化连接条件（join condition）</h3><p>连接条件是<code>(cond1 &amp;&amp; cond2)</code>或<code>(cond1 || cond2)</code>类型的条件。根据C和C++标准，在<code>(cond1 &amp;&amp; cond2)</code>的情况下，如果<code>cond1</code>为<code>false</code>，则不会评估<code>cond2</code>。类似地，在<code>(cond1 || cond2)</code>的情况下，如果<code>cond1</code>为<code>true</code>，则不会评估<code>cond2</code>。</p><h3 id="3-4-2-优化if-else结构"><a href="#3-4-2-优化if-else结构" class="headerlink" title="3.4.2. 优化if&#x2F;else结构"></a>3.4.2. 优化if&#x2F;else结构</h3><p>以如下代码为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0</span>) &#123; </span><br><span class="line">   <span class="built_in">do_something_else</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">do_something_yet_else</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在考虑<code>(a &lt; 0)</code>的概率为70%，<code>(a &gt; 0)</code>为20%，<code>(a == 0)</code>为10%。在这种情况下，重新排列上述代码是最合乎逻辑的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="built_in">do_something_yet_else</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123; </span><br><span class="line">   <span class="built_in">do_something</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">do_something_else</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-3-使用查找表替换switch语句"><a href="#3-4-3-使用查找表替换switch语句" class="headerlink" title="3.4.3. 使用查找表替换switch语句"></a>3.4.3. 使用查找表替换switch语句</h3><p>在删除分支时，查找表（lookup table, LUT）有时会很方便。不幸的是，在switch语句中，分支在大多数情况下很容易预测，因此这种优化可能不会产生任何效果。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY: <span class="keyword">return</span> <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY: <span class="keyword">return</span> <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">case</span> SUNDAY: <span class="keyword">return</span> <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的语句可以使用LUT来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (day &lt; MONDAY || day &gt; SUNDAY) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">char</span>* days_to_string = &#123; <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, ... , <span class="string">&quot;Sunday&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">return</span> days_to_string[day - MONDAY];</span><br></pre></td></tr></table></figure><p>通常，编译器可以通过用查找表替换开关来为完成这项工作。</p><h3 id="3-4-4-将最常见的情况移出switch语句"><a href="#3-4-4-将最常见的情况移出switch语句" class="headerlink" title="3.4.4. 将最常见的情况移出switch语句"></a>3.4.4. 将最常见的情况移出switch语句</h3><p>如果使用switch命令并且其中一种情况似乎最常见，可以将其移出switch并给予特殊处理。继续上一节的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">day <span class="title">get_first_workday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::chrono::weekday first_workday = <span class="built_in">read_first_workday</span>();</span><br><span class="line">    <span class="keyword">if</span> (first_workday == Monday) &#123; <span class="keyword">return</span> day::Monday; &#125;</span><br><span class="line">    <span class="keyword">switch</span>(first_workday) &#123; </span><br><span class="line">        <span class="keyword">case</span> Tuesday: <span class="keyword">return</span> day::Tueasday;</span><br><span class="line">        ....</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-5-重写连接条件"><a href="#3-4-5-重写连接条件" class="headerlink" title="3.4.5. 重写连接条件"></a>3.4.5. 重写连接条件</h3><p>如前所述，在连接条件的情况下，如果第一个条件具有特定值，则根本不需要评估第二个条件。编译器是如何做到这一点的？以下面的函数为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i] &gt; x &amp;&amp; a[i] &lt; y) &#123;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设<code>a[i] &gt; x</code>和<code>a[i] &lt; y</code>评估起来很便宜（所有数据都在寄存器或缓存中）但难以预测。该序列将转换为以下伪汇编程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if_not (a[i] &gt; x) <span class="keyword">goto</span> ENDIF;</span><br><span class="line">if_not (a[i] &lt; y) <span class="keyword">goto</span> ENDIF;</span><br><span class="line">do_something;</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure><p>这里有两个难以预测的分支。如果我们用<code>&amp;</code>而不是<code>&amp;&amp;</code>连接两个条件，我们将：</p><ul><li>强制同时评估两个条件：<code>&amp;</code>运算符是算术<code>AND</code>运算，并且必须评估两边。</li><li>使条件更容易预测，从而降低分支误预测率：两个完全独立的条件（概率为50%）将产生一个联合条件（概率为25%）。</li><li>摆脱一个分支：我们将拥有一个更容易预测的分支，而不是原来的两个分支。</li></ul><p>运算符<code>&amp;</code>评估这两个条件，并且在生成的程序集中将只有一个分支而不是两个。同样的情况也适用于运算符<code>||</code>及其孪生运算符<code>|</code>。<br>请注意：根据C++标准，bool类型的值为0表示false，任何其他值表示true。C++标准保证逻辑运算和算术比较的结果始终为零或一，但不能保证所有布尔值都只有这两个值。您可以通过应用<code>!!</code>来标准化<code>bool</code>变量其上的操作。</p><h3 id="3-4-6-向编译器建议哪个分支概率更高"><a href="#3-4-6-向编译器建议哪个分支概率更高" class="headerlink" title="3.4.6. 向编译器建议哪个分支概率更高"></a>3.4.6. 向编译器建议哪个分支概率更高</h3><p>GCC和CLANG提供了关键字，程序员可以使用这些关键字来告诉他们哪些分支具有更高的概率。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x)      __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x)    __builtin_expect(!!(x), 0)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">likely</span>(ptr)) &#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们通过可能和不太可能的宏使用<code>__builtin_expect</code>，因为它们的语法在任何地方使用都很麻烦。当这样注释时，编译器将重新排列if和else分支中的指令，以便最优化地使用底层硬件。请确保条件概率正确，否则性能可能会下降。</p><h3 id="3-4-7-使用无分支算法"><a href="#3-4-7-使用无分支算法" class="headerlink" title="3.4.7. 使用无分支算法"></a>3.4.7. 使用无分支算法</h3><p>一些用分支表达的算法可以转换为无分支算法。例如，下面的函数<code>abs</code>使用一种技巧来计算数字的绝对值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> mask = a &gt;&gt; <span class="built_in">sizeof</span>(<span class="type">int</span>) * CHAR_BIT - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (a + mask) ^ mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-8-使用条件加载而不是分支"><a href="#3-4-8-使用条件加载而不是分支" class="headerlink" title="3.4.8. 使用条件加载而不是分支"></a>3.4.8. 使用条件加载而不是分支</h3><p>许多CPU支持可用于删除分支的条件移动指令。这是一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以重写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> new_x = x + <span class="number">1</span>;</span><br><span class="line">x = (x &gt; y) ? new_x : x; <span class="comment">// the compiler should recognize this and emit a conditional branch</span></span><br></pre></td></tr></table></figure><p>编译器应该认识到第2行的命令可以写为变量<code>x</code>的条件加载并发出条件移动指令。不幸的是，编译器对于何时发出条件分支有自己的内部逻辑，这并不总是像开发人员所期望的那样。但是，可以使用内联汇编来强制条件加载。</p><h3 id="3-4-9-通过算术实现无分支"><a href="#3-4-9-通过算术实现无分支" class="headerlink" title="3.4.9. 通过算术实现无分支"></a>3.4.9. 通过算术实现无分支</h3><p>有一种方法可以通过巧妙地使用算术运算来实现无分支。条件增量示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With branch</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    x += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Branchless</span></span><br><span class="line">x += -(a &gt; b) &amp; y; </span><br></pre></td></tr></table></figure><p>在上面的示例中，表达式<code>-(a &gt; b)</code>将创建一个掩码，当条件为假时，该掩码为0；当条件为真时，该掩码全为1。</p><p>条件赋值的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With branch</span></span><br><span class="line">x = (a &gt; b) ? val_a : val_b;</span><br><span class="line"><span class="comment">// Branchless</span></span><br><span class="line">x = val_a;</span><br><span class="line">x += -(a &gt; b) &amp; (val_b - val_a);</span><br></pre></td></tr></table></figure><p>在循环缓冲区中移动索引的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With branch</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_next_element</span><span class="params">(<span class="type">int</span> current, <span class="type">int</span> buffer_len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (next == buffer_len) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Branchless</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_next_element_branchless</span><span class="params">(<span class="type">int</span> current, <span class="type">int</span> buffer_len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (next &lt; buffer_len) * next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-10-重新组织代码以避免分支"><a href="#3-4-10-重新组织代码以避免分支" class="headerlink" title="3.4.10. 重新组织代码以避免分支"></a>3.4.10. 重新组织代码以避免分支</h3><p>假设您有一个名为<code>animation</code>的类，它可以是可见的也可以是隐藏的。处理可见<code>animation</code>与处理隐藏<code>animation</code>有很大不同。有一个包含名为<code>animation_list</code>的<code>animation</code>的列表，处理如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> animation&amp; a: animation_list) &#123;</span><br><span class="line">    a.<span class="built_in">step_a</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">is_visible</span>()) &#123;</span><br><span class="line">        a.<span class="built_in">step_av</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">step_b</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.is_visible) &#123;</span><br><span class="line">        a.<span class="built_in">step_bv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非<code>animation</code>根据可见性进行排序，否则分支预测器确实很难处理上述代码。有两种方法可以解决这个问题。一是根据<code>is_visible()</code>对<code>animation_list</code>中的动画进行排序。第二种是创建两个列表，<code>animation_list_visible</code>和<code>animation_list_hidden</code>，并重写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> animation&amp; a: animation_list_visible) &#123;</span><br><span class="line">    a.<span class="built_in">step_a</span>();</span><br><span class="line">    a.<span class="built_in">step_av</span>();</span><br><span class="line">    a.<span class="built_in">step_b</span>();</span><br><span class="line">    a.<span class="built_in">step_bv</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> animation&amp; a: animation_list_hidden) &#123;</span><br><span class="line">    a.<span class="built_in">step_a</span>();</span><br><span class="line">    a.<span class="built_in">step_b</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的条件都消失了，并且没有分支错误预测。</p><h3 id="3-4-11-使用模板删除分支"><a href="#3-4-11-使用模板删除分支" class="headerlink" title="3.4.11. 使用模板删除分支"></a>3.4.11. 使用模板删除分支</h3><p>如果将布尔值传递给函数并且在函数内部将其用作参数，则可以通过将其作为模板参数传递来删除它。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">average</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> len, <span class="type">bool</span> include_negatives)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> average = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (include_negatives) &#123;</span><br><span class="line">            average += array[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                average += array[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (include_negatives) &#123;</span><br><span class="line">         <span class="keyword">return</span> average / len;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> average / count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此函数中，可以多次评估<code>include_negatives</code>的条件。要删除评估，请将参数作为模板参数而不是函数参数传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> include_negatives&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">average</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> average = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (include_negatives) &#123;</span><br><span class="line">            average += array[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                average += array[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (include_negatives) &#123;</span><br><span class="line">         <span class="keyword">return</span> average / len;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> average / count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过此实现，编译器将生成该函数的两个版本，一种带有<code>include_negatives</code>，一种不带有<code>include_negatives</code>（以防调用此参数具有不同值的函数）。分支完全消失了，未使用的分支中的代码也消失了。</p><p>但现在需要以不同的方式调用您的函数。所以会这样称呼它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> avg;</span><br><span class="line"><span class="type">bool</span> should_include_negatives = <span class="built_in">get_should_include_negatives</span>();</span><br><span class="line"><span class="keyword">if</span> (should_include_negatives) &#123;</span><br><span class="line">    avg = <span class="built_in">average</span>&lt;<span class="literal">true</span>&gt;(array, len);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    avg = <span class="built_in">average</span>&lt;<span class="literal">false</span>&gt;(array, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上是一种称为<code>branch optimization</code>的编译器优化。如果<code>include_negatives</code>的值在编译时已知并且编译器决定内联函数平均值，它将删除分支和未使用的代码。然而，带有模板的版本保证了这一点，而原始版本则不然。</p><p>编译器通常可以进行这种优化。如果编译器可以保证值<code>include_negatives</code>在循环执行期间不会更改其值，则它可以创建两个版本的循环：一种用于其值为<code>true</code>的情况，另一种用于其值为<code>false</code>的情况。这种优化称为循环不变代码优化。</p><h3 id="3-4-12-避免分支的其他一些技巧"><a href="#3-4-12-避免分支的其他一些技巧" class="headerlink" title="3.4.12. 避免分支的其他一些技巧"></a>3.4.12. 避免分支的其他一些技巧</h3><p>如果在代码中多次检查不可更改的条件，则通过检查一次然后进行一些代码复制可能会获得更好的性能。因此，在下面的示例中，两个分支可以替换为一个分支。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_visible) &#123;</span><br><span class="line">    <span class="built_in">hide</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">process</span>();</span><br><span class="line"><span class="keyword">if</span> (is_visible) &#123;</span><br><span class="line">    <span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以替换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_visible) &#123;</span><br><span class="line">    <span class="built_in">hide</span>();</span><br><span class="line">    <span class="built_in">process</span>();</span><br><span class="line">    <span class="built_in">display</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以引入一个两元素数组，一个用于在条件为<code>true</code>时保存结果，另一个用于在条件为<code>false</code>时保存结果。一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> larger = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; m) &#123;</span><br><span class="line">        larger++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> larger;</span><br></pre></td></tr></table></figure><p>可以替换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result[] = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result[a&gt;i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h2 id="3-5-实验"><a href="#3-5-实验" class="headerlink" title="3.5. 实验"></a>3.5. 实验</h2><p>作者在“AMD A8-4500M quad-core x86-64” ，“Allwinner sun7i A20 dual-core ARMv7”和“Ingenic JZ4780 dual-core MIPS32r2”三种处理器上进行了多组对照试验，具体细节暂不描述，结论如下：</p><p>分支推测打破了一些数据依赖性，并有效地掩盖了CPU需要等待内存数据的时间。如果分支预测器的猜测是正确的，那么当数据从内存到达时，很多工作就已经完成了。对于无分支的代码来说，情况并非如此。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态链接</title>
      <link href="/2020/01/02/static-link/"/>
      <url>/2020/01/02/static-link/</url>
      
        <content type="html"><![CDATA[<p>TODO</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
