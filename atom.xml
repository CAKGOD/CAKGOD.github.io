<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CAKGOD&#39;s blog</title>
  
  
  <link href="http://cakgod.github.io/atom.xml" rel="self"/>
  
  <link href="http://cakgod.github.io/"/>
  <updated>2023-10-12T05:42:36.173Z</updated>
  <id>http://cakgod.github.io/</id>
  
  <author>
    <name>CAKGOD</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git使用总结</title>
    <link href="http://cakgod.github.io/2023/10/12/git-using/"/>
    <id>http://cakgod.github.io/2023/10/12/git-using/</id>
    <published>2023-10-12T05:40:00.000Z</published>
    <updated>2023-10-12T05:42:36.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文总结了一些git的日常使用命令和一些问题解决方法。</p><h1 id="2-详述"><a href="#2-详述" class="headerlink" title="2. 详述"></a>2. 详述</h1><h2 id="2-1-如何用分支a完全覆盖分支b"><a href="#2-1-如何用分支a完全覆盖分支b" class="headerlink" title="2.1. 如何用分支a完全覆盖分支b"></a>2.1. 如何用分支a完全覆盖分支b</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout b</span><br><span class="line">git reset --hard origin/a</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;本文总结了一些git的日常使用命令和一些问题解决方法。&lt;/p&gt;
&lt;h1 id=&quot;2-详述&quot;&gt;&lt;a href=&quot;#2-详述</summary>
      
    
    
    
    
    <category term="linux" scheme="http://cakgod.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux命令总结</title>
    <link href="http://cakgod.github.io/2023/10/12/linux-command/"/>
    <id>http://cakgod.github.io/2023/10/12/linux-command/</id>
    <published>2023-10-12T01:57:31.275Z</published>
    <updated>2023-10-12T01:57:31.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>该文章总结了一些linux系统中常用的命令以及部分软件使用的命令。</p><h1 id="2-详述"><a href="#2-详述" class="headerlink" title="2. 详述"></a>2. 详述</h1><h2 id="2-1-ar"><a href="#2-1-ar" class="headerlink" title="2.1. ar"></a>2.1. ar</h2><p>ar命令用来制作静态库，一些常用的参数：</p><ul><li>-c：禁止在创建库时产生的正常消息。</li><li>-r：如果指定的文件已经在库中存在，则替换它。</li><li>-s：无论库是否更新都强制重新生成新的符号表。</li><li>-d：从库中删除指定的文件。</li><li>-o：对压缩文档成员进行排序。</li><li>-q：向库中追加指定文件。 </li><li>-t：打印库中的目标文件。</li><li>-x：解压库中的目标文件。编译器是以源文件为单位编译程序的，链接器在链接过程中逐个对目标文件进行分解组装。</li></ul><h2 id="2-2-关机、重启、登录、注销"><a href="#2-2-关机、重启、登录、注销" class="headerlink" title="2.2. 关机、重启、登录、注销"></a>2.2. 关机、重启、登录、注销</h2><ul><li>shutdown -h now：立即关机</li><li>shutdown -h 1：一分钟后关机</li><li>shutdown -r now：重启</li><li>halt：关机</li><li>reboot：重启</li><li>sync：把内存的数据同步到磁盘</li><li>logout：注销</li></ul><h2 id="2-3-用户"><a href="#2-3-用户" class="headerlink" title="2.3. 用户"></a>2.3. 用户</h2><ul><li>useradd：添加用户</li><li>passwd：更改密码</li><li>userdel username：删除用户</li><li>userdel -r username：删除用户并删除对应的home目录</li><li>id username：查询用户</li><li>su - username：切换用户</li><li>exit或logout：返回原用户</li><li>who am i：显示登入的信息</li></ul><h2 id="2-4-用户组"><a href="#2-4-用户组" class="headerlink" title="2.4. 用户组"></a>2.4. 用户组</h2><ul><li>groupadd groupname：新增组</li><li>groupdel groupname：删除组</li><li>useradd -g groupname username：新增用户时直接加上组</li></ul><h2 id="2-5-帮助指令"><a href="#2-5-帮助指令" class="headerlink" title="2.5. 帮助指令"></a>2.5. 帮助指令</h2><ul><li>man：获取帮助信息</li><li>help：获取shell内置命令的帮助信息</li></ul><h2 id="2-6-文件目录类"><a href="#2-6-文件目录类" class="headerlink" title="2.6. 文件目录类"></a>2.6. 文件目录类</h2><p>pwd：显示当前所在目录</p><p>ls：显示当前目录下文件</p><ul><li>-a或—all：不隐藏任何以. 开始的项目</li><li>-r或—reverse：将排序结果反向输出</li><li>-s或—size：以块数形式显示每个文件分配的尺寸</li><li>-t：以文件修改时间排序（从最新开始排）</li><li>-h：将文件大小以GB MB KB的方式列出</li></ul><p>cd：进入目录</p><ul><li>cd ~：返回自己的home目录</li><li>cd ..：到上级目录</li></ul><p>mkdir：创建目录，默认创建一级目录，</p><ul><li>-p：创建多级目录</li></ul><p>rmdir：删除目录</p><p>touch：创建空文件</p><p>cp src dest：拷贝src文件并命令为dest，加-r选项实现对文件夹的拷贝</p><p>rm：删除文件</p><ul><li>-r：递归删除整个文件夹</li><li>-f：强制删除不提示</li></ul><p>mv：移动</p><ul><li>mv oldFileName newFileName：重命名</li><li>mv oldFilePath newFilePath：移动文件或文件夹</li></ul><p>echo：输出内容到控制台</p><p>head：显示文件的开头部分内容</p><ul><li>-n lineNum：指定显示行数</li></ul><p>tail：显示文件的尾部内容</p><p>>：输出重定向</p><p>>>：内容追加</p><p>ln：建立链接</p><ul><li>-s或—symbolic：对源文件建立软链接（符号连接），而非硬连接</li><li>-d或-F或—directory：建立目录的硬连接</li><li>-f或—force：强行建立文件或目录的连接，不论文件或目录是否存在</li></ul><p>history：查看已经执行过的历史命令</p><h2 id="2-7-日期时间类"><a href="#2-7-日期时间类" class="headerlink" title="2.7. 日期时间类"></a>2.7. 日期时间类</h2><ul><li>date：显示系统当前时间</li><li>date +”%Y-%m-%d %H：%M：%S”：显示年月日时分秒</li><li>date -s time：设置系统当前时间</li><li>cal：显示本月日历</li></ul><h2 id="2-8-搜索查找类"><a href="#2-8-搜索查找类" class="headerlink" title="2.8. 搜索查找类"></a>2.8. 搜索查找类</h2><p>find：将从指定目录向下递归遍历其子目录，将满足条件的文件或目录显示在终端</p><ul><li>-name：按文件名称查找，区分大小写</li><li>-iname：按文件名称查找，不区分字母大小写</li><li>-path：按文件的目录查找</li><li>-size：按文件大小来查找</li><li>-type：按文件类型查找</li></ul><p>其中-type参数如下：</p><ul><li>f：普通文件</li><li>d：目录文件</li><li>l：符号链接文件</li><li>s：套接字文件</li><li>b：块设备文件</li><li>c：字符设备文件</li><li>p：管道文件</li></ul><p>grep：文本搜索工具，根据用户指定的“模式（过滤条件）”对目标文本逐行进行匹配检查，打印匹配到的行</p><ul><li>-i：忽略大小写</li><li>-c：输出匹配行的计数</li><li>-r：递归搜索</li><li>-n：打印包含匹配项的行和行标</li><li>-w：匹配 整个单词</li><li>-q：静默模式，不输出任何信息</li><li>-v： 显示不匹配的行</li></ul><p>|：管道符，将上一条指令的处理结果交给下一条指令来处理</p><p>which：查看某个指令在哪个目录下</p><h2 id="2-9-压缩和解压类"><a href="#2-9-压缩和解压类" class="headerlink" title="2.9. 压缩和解压类"></a>2.9. 压缩和解压类</h2><p>zip：压缩文件</p><ul><li>-r：递归压缩</li><li>-d：指定压缩文件的存放目录</li><li>-q：不显示指令执行过程</li><li>-v：显示指令执行过程或显示版本信息</li></ul><p>unzip：解压文件</p><ul><li>-q：不显示指令执行过程</li></ul><p>tar：归档文件</p><ul><li>-c：建立一个压缩文件的参数指令</li><li>-x：解开一个压缩文件的参数指令</li><li>-t：查看 tarfile 里面的文件</li><li>-r：向压缩归档文件末尾追加文件</li><li>-u：更新原压缩包中的文件</li><li>-z：有gzip属性,即需要用 gzip 压缩</li><li>-j：有bz2属性,即需要用 bzip2 压缩</li><li>-v ：压缩的过程中显示文件（显示所有过程）</li><li>-O：将文件解开到标准输出</li><li>—exclude FILE：在压缩的过程中，不要将 FILE 打包</li><li>-f： 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名</li></ul><h2 id="2-10-组管理和权限管理"><a href="#2-10-组管理和权限管理" class="headerlink" title="2.10. 组管理和权限管理"></a>2.10. 组管理和权限管理</h2><p>chown：修改文件所有者</p><p>groupadd：组的创建</p><p>chmod：修改权限，可通过数字变更权限，r=4,w=2,x=1,rwx = 4+2+1=7,0则没有权限</p><ul><li>r：可读</li><li>w：可写</li><li>x：可执行</li></ul><h2 id="2-11-进程管理"><a href="#2-11-进程管理" class="headerlink" title="2.11. 进程管理"></a>2.11. 进程管理</h2><p>ps：显示系统执行的进程</p><ul><li>-a：显示当前终端的所有进程信息</li><li>-u：以用户的格式显示进程信息</li><li>-x：显示后台进程运行的参数</li></ul><p>kill：终止进程</p><ul><li>-9表示强制停止进程</li></ul><p>pstree：查看进程树</p><ul><li>-p：显示进程的pid</li><li>-u：显示进程的所属用户</li></ul><h2 id="2-12-参考文件"><a href="#2-12-参考文件" class="headerlink" title="2.12. 参考文件"></a>2.12. 参考文件</h2><ul><li><a href="https://blog.csdn.net/guorui_java/article/details/117430091">https://blog.csdn.net/guorui_java/article/details/117430091</a></li><li><a href="https://blog.csdn.net/wq1205750492/article/details/124497195">https://blog.csdn.net/wq1205750492/article/details/124497195</a></li><li><a href="https://blog.csdn.net/qq_55316925/article/details/128092949">https://blog.csdn.net/qq_55316925/article/details/128092949</a></li><li><a href="https://www.cnbugs.com/post-4092.html">https://www.cnbugs.com/post-4092.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;该文章总结了一些linux系统中常用的命令以及部分软件使用的命令。&lt;/p&gt;
&lt;h1 id=&quot;2-详述&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="linux" scheme="http://cakgod.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="http://cakgod.github.io/2023/10/08/smart-pointer/"/>
    <id>http://cakgod.github.io/2023/10/08/smart-pointer/</id>
    <published>2023-10-08T03:56:20.000Z</published>
    <updated>2023-10-09T02:15:51.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在实际的C++开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p><ul><li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li><li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li><li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li></ul><p>C++98&#x2F;03标准中，支持使用<code>auto_ptr</code>智能指针来实现堆内存的自动回收；C++11新标准在废弃<code>auto_ptr</code>的同时，增添了<code>unique_ptr</code>、<code>shared_ptr</code>以及<code>weak_ptr</code>这3个智能指针来实现堆内存的自动回收。</p><p>C++智能指针底层是采用引用计数的方式实现的。简单理解，智能指针在申请堆内存空间的同时，会为其配备一个整型值（初始值为1），每当有新对象使用此堆内存时，该整形值加1；反之，每当使用此堆内存的对象被释放时，该整型值减1。当堆空间对应的整型值为0时，即表明不再有对象使用它，该堆空间就会被释放掉。</p><p>下面介绍三种智能指针，注意：每种智能指针都是以类模板的方式实现的，定义位于<code>&lt;memory&gt;</code>头文件，并位于<code>std</code>命名空&gt;间中，因此在使用该类型指针时，程序中应包含如下2行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h1 id="2-shared-ptr"><a href="#2-shared-ptr" class="headerlink" title="2. shared_ptr"></a>2. shared_ptr</h1><p>和<code>unique_ptr</code>、<code>weak_ptr</code>不同之处在于，多个<code>shared_ptr</code>智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个shared_ptr&#96;指针放弃了堆内存的“使用权”（引用计数减1），也不会影响其他指向同一堆内存的shared_ptr指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p><h2 id="2-1-创建"><a href="#2-1-创建" class="headerlink" title="2.1. 创建"></a>2.1. 创建</h2><p>介绍一下几种创建方式：</p><p>（1）创建空智能指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1;             <span class="comment">// 不传入任何实参</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;    <span class="comment">// 传入空指针nullptr</span></span><br></pre></td></tr></table></figure><p>注意，空的<code>shared_ptr</code>指针，其初始引用计数为0，而不是1。</p><p>（2）创建非空<code>shared_ptr</code>智能指针，明确其指向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>这样就成功构建了一个<code>shared_ptr</code>智能指针，其指向一块存有10个int类型数据的堆内存空间。</p><p>同时，C++11标准中还提供了<code>std::make_shared&lt;T&gt;</code>模板函数，其可以用于初始化<code>shared_ptr</code>智能指针，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>以上2种方式创建的p3是完全相同。</p><p>（3）拷贝构造和移动构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p4 = p3;</span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p5 = std::<span class="built_in">move</span>(p4);</span><br></pre></td></tr></table></figure><p>如上所示，p3和p4都是<code>shared_ptr</code>类型的智能指针，因此可以用p3来初始化p4，由于p3是左值，因此会调用拷贝构造函数。需要注意的是，如果p3为空智能指针，则p4也为空智能指针，其引用计数初始值为0；反之，则表明p4和p3指向同一块堆内存，同时该堆空间的引用计数会加1。</p><p>而对于<code>std::move(p4)</code>来说，该函数会强制将p4转换成对应的右值，因此初始化p5调用的是移动构造函数。另外和调用拷贝构造函数不同，用<code>std::move(p4)</code>初始化p5，会使得p5拥有了p4的堆内存，而p4则变成了空智能指针。</p><p>注意，同一普通指针不能同时为多个<code>shared_ptr</code>对象赋值，否则会导致程序发生异常。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h2 id="2-2-释放"><a href="#2-2-释放" class="headerlink" title="2.2. 释放"></a>2.2. 释放</h2><p>再介绍一下<code>shared_ptr</code>的自定义释放规则，在初始化时可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为0时，会优先调用自定义的释放规则。在某些场景中，自定义释放规则是很有必要的。比如，对于申请的动态数组来说，<code>shared_ptr</code>指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。</p><p>对于申请的动态数组，释放规则可以使用C++11标准中提供的<code>default_delete&lt;T&gt;</code>模板类，也可以自定义释放规则：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定 default_delete 作为释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义释放规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteInt</span><span class="params">(<span class="type">int</span>*p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化智能指针，并自定义释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], deleteInt)</span></span>;</span><br></pre></td></tr></table></figure><p>借助lambda表达式，还可以像如下这样初始化p7：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123; <span class="keyword">delete</span> []p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3. 方法"></a>2.3. 方法</h2><p>总结一下<code>shared_ptr</code>的成员方法：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td><code>operator=()</code></td><td>重载赋值号，使得同一类型的<code>shared_ptr</code>智能指针可以相互赋值。</td></tr><tr><td><code>operator*()</code></td><td>重载<code>*</code>号，获取当前<code>shared_ptr</code>智能指针对象指向的数据。</td></tr><tr><td><code>operator-&gt;()</code></td><td>重载<code>-&gt;</code>号，当智能指针指向的数据类型为自定义的结构体时，通过<code>-&gt;</code>运算符可以获取其内部的指定成员。</td></tr><tr><td><code>swap()</code></td><td>交换2个相同类型<code>shared_ptr</code>智能指针的内容。</td></tr><tr><td><code>reset()</code></td><td>当函数没有实参时，该函数会使当前<code>shared_ptr</code>所指堆内存的引用计数减1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的<code>shared_ptr</code>对象会获得该存储空间的所有权，并且引用计数的初始值为1。</td></tr><tr><td><code>get()</code></td><td>获得<code>shared_ptr</code>对象内部包含的普通指针。</td></tr><tr><td><code>use_count()</code></td><td>返回同当前<code>shared_ptr</code>对象（包括它）指向相同的所有<code>shared_ptr</code>对象的数量。</td></tr><tr><td><code>unique()</code></td><td>判断当前<code>shared_ptr</code>对象指向的堆内存，是否不再有其它<code>shared_ptr</code>对象再指向它。</td></tr><tr><td><code>operator bool()</code></td><td>判断当前<code>shared_ptr</code>对象是否为空智能指针，如果是空指针，返回false；反之，返回true。</td></tr></tbody></table><h1 id="3-unique-ptr"><a href="#3-unique-ptr" class="headerlink" title="3. unique_ptr"></a>3. unique_ptr</h1><p>作为智能指针的一种，<code>unique_ptr</code>指针也具备“在适当时机自动释放堆内存空间”的能力。和<code>shared_ptr</code>指针最大的不同之处在于，<code>unique_ptr</code>指针指向的堆内存无法同其它<code>unique_ptr</code>共享，也就是说，每个<code>unique_ptr</code>指针都独自拥有对其所指堆内存空间的所有权。</p><p>这也就意味着，每个<code>unique_ptr</code>指针指向的堆内存空间的引用计数，都只能为1，一旦该<code>unique_ptr</code>指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。</p><h2 id="3-1-创建"><a href="#3-1-创建" class="headerlink" title="3.1. 创建"></a>3.1. 创建</h2><p>（1）创建空<code>unique_ptr</code>指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>（2）创建非空<code>unique_ptr</code>指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>（3）移动构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(p4)</span></span>;<span class="comment">//错误，堆内存不共享</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>;<span class="comment">//正确，调用移动构造函数</span></span><br></pre></td></tr></table></figure><h2 id="3-2-释放"><a href="#3-2-释放" class="headerlink" title="3.2. 释放"></a>3.2. 释放</h2><p>默认情况下，<code>unique_ptr</code>指针采用<code>std::default_delete&lt;T&gt;</code>方法释放堆内存。当然，我们也可以自定义符合实际场景的释放规则。值得一提的是，和<code>shared_ptr</code>指针不同，为<code>unique_ptr</code>自定义释放规则，只能采用函数对象的方式。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的释放规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myDel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>, myDel&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//std::unique_ptr&lt;int, myDel&gt; p6(new int, myDel());</span></span><br></pre></td></tr></table></figure><h2 id="3-3-方法"><a href="#3-3-方法" class="headerlink" title="3.3. 方法"></a>3.3. 方法</h2><p>总结一下<code>unique_ptr</code>的成员方法：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td><code>operator=()</code></td><td>重载赋值号，从而可以将nullptr或者一个右值<code>unique_ptr</code>指针直接赋值给当前同类型的<code>unique_ptr</code>指针。</td></tr><tr><td><code>operator*()</code></td><td>重载<code>*</code>号，获取当前<code>unique_ptr</code>智能指针对象指向的数据。</td></tr><tr><td><code>operator-&gt;()</code></td><td>重载<code>-&gt;</code>号，当智能指针指向的数据类型为自定义的结构体时，通过<code>-&gt;</code>运算符可以获取其内部的指定成员。</td></tr><tr><td><code>operator[]()</code></td><td>重载<code>[]</code>号，当<code>unique_ptr</code>指针指向一个数组时，可以直接通过<code>[]</code>获取指定下标位置处的数据。</td></tr><tr><td><code>swap(x)</code></td><td>交换当前<code>unique_ptr</code>指针和同类型的<code>x</code>指针。</td></tr><tr><td><code>reset(p)</code></td><td>其中p表示一个普通指针，如果p为nullptr，则当前<code>unique_ptr</code>也变成空指针；反之，则该函数会释放当前<code>unique_ptr</code>指针指向的堆内存（如果有），然后获取<code>p</code>所指堆内存的所有权（p为nullptr）。</td></tr><tr><td><code>get()</code></td><td>获得<code>unique_ptr</code>对象内部包含的普通指针。</td></tr><tr><td><code>get_deleter()</code></td><td>获取当前<code>unique_ptr</code>指针释放堆内存空间所用的规则。</td></tr><tr><td><code>release()</code></td><td>释放当前<code>unique_ptr</code>指针对所指堆内存的所有权，但该存储空间并不会被销毁。</td></tr><tr><td><code>operator bool()</code></td><td><code>unique_ptr</code>指针可直接作为<code>if</code>语句的判断条件，以判断该指针是否为空，如果为空，则为false；反之为true。</td></tr></tbody></table><h1 id="4-weak-ptr"><a href="#4-weak-ptr" class="headerlink" title="4. weak_ptr"></a>4. weak_ptr</h1><p>C++11标准虽然将<code>weak_ptr</code>定位为智能指针的一种，但该类型指针通常不单独使用（没有实际用处），只能和<code>shared_ptr</code>类型指针搭配使用。甚至于，我们可以将<code>weak_ptr</code>类型指针视为<code>shared_ptr</code>指针的一种辅助工具，借助<code>weak_ptr</code>类型指针，我们可以获取<code>shared_ptr</code>指针的一些状态信息，比如有多少指向相同的<code>shared_ptr</code>指针、<code>shared_ptr</code>指针指向的堆内存是否已经被释放等等。</p><p>需要注意的是，当<code>weak_ptr</code>类型指针的指向和某一<code>shared_ptr</code>指针相同时，<code>weak_ptr</code>指针并不会使所指堆内存的引用计数加1；同样，当<code>weak_ptr</code>指针被释放时，之前所指堆内存的引用计数也不会因此而减1。也就是说，<code>weak_ptr</code>类型指针并不会影响所指堆内存空间的引用计数。</p><p>除此之外，<code>weak_ptr&lt;T&gt;</code>模板类中没有重载<code>*</code>和<code>-&gt;</code>运算符，这也就意味着，<code>weak_ptr</code>类型指针只能访问所指的堆内存，而无法修改它。</p><h2 id="4-1-创建"><a href="#4-1-创建" class="headerlink" title="4.1. 创建"></a>4.1. 创建</h2><p>（1）创建空<code>weak_ptr</code>指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br></pre></td></tr></table></figure><p>（2）根据已有<code>weak_ptr</code>指针创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span> <span class="params">(wp1)</span></span>;</span><br></pre></td></tr></table></figure><p>（3）根据已有<code>shared_ptr</code>指针创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span> <span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span> <span class="params">(sp)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2. 方法"></a>4.2. 方法</h2><p>总结一下<code>weak_ptr</code>的成员方法：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td><code>operator=()</code></td><td>重载赋值号，使得<code>weak_ptr</code>指针可以直接被<code>weak_ptr</code>或者<code>shared_ptr</code>类型指针赋值。</td></tr><tr><td><code>swap(x)</code></td><td>其中<code>x</code>表示一个同类型的<code>weak_ptr</code>类型指针，该函数可以互换2个同类型<code>weak_ptr</code>指针的内容。</td></tr><tr><td><code>reset()</code></td><td>将当前 weak_ptr 指针置为空指针。</td></tr><tr><td><code>use_count()</code></td><td>查看指向和当前<code>weak_ptr</code>指针相同的<code>shared_ptr</code>指针的数量。</td></tr><tr><td><code>expired()</code></td><td>判断当前<code>weak_ptr</code>指针为否过期（指针为空，或者指向的堆内存已经被释放）。</td></tr><tr><td><code>lock()</code></td><td>如果当前<code>weak_ptr</code>已经过期，则该函数会返回一个空的<code>shared_ptr</code>指针；反之，该函数返回一个和当前<code>weak_ptr</code>指向相同的<code>shared_ptr</code>指针。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;在实际的C++开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都</summary>
      
    
    
    
    
    <category term="c++" scheme="http://cakgod.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>有趣的网站</title>
    <link href="http://cakgod.github.io/2023/09/28/interesting-website/"/>
    <id>http://cakgod.github.io/2023/09/28/interesting-website/</id>
    <published>2023-09-28T01:34:18.000Z</published>
    <updated>2023-10-16T02:21:44.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>记录一些有趣的网站、工具或者文章。这些信息来源比较广泛，有些比较实用的也许会单独拆出来另外写一篇，有些不太实用（比如waiting list，WIP，搞怪等）的会先放在这里。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><ul><li>阮一峰大神的分享：<a href="https://github.com/ruanyf/weekly">科技爱好者周刊</a></li><li>其他</li></ul><h1 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h1><h2 id="1-AI应用"><a href="#1-AI应用" class="headerlink" title="1. AI应用"></a>1. AI应用</h2><h3 id="1-网页生成"><a href="#1-网页生成" class="headerlink" title="(1) 网页生成"></a>(1) 网页生成</h3><ul><li><a href="https://v0.dev/">v0</a> （waiting list）Vercel推出的一个实验性产品，使用AI生成网页。输入对页面需求的文字描述，会给出UI设计。应该是目前最强的AI网页生成器。</li></ul><h3 id="2-财经"><a href="#2-财经" class="headerlink" title="(2) 财经"></a>(2) 财经</h3><ul><li><a href="https://finchat.io/">findchat</a> AI财报分析，可以解析上市公司财报（包含美股、港股、沪深A股），并支持对财报内容提问。</li><li><a href="https://beebee.ai/">beebee</a> 与findchat功能类似</li></ul><h3 id="3-搜索"><a href="#3-搜索" class="headerlink" title="(3) 搜索"></a>(3) 搜索</h3><ul><li><a href="https://cn.noteai.com/">noteai</a> 用户在该网站输入问题，它会用AI从搜索引擎返回的网页结果里面，总结出答案。</li><li></li></ul><h3 id="4-语音"><a href="#4-语音" class="headerlink" title="(4) 语音"></a>(4) 语音</h3><ul><li><a href="https://huggingface.co/spaces/Xenova/whisper-web">whisper</a> 将英语音频转成文本的在线工具。</li></ul><h3 id="5-图像"><a href="#5-图像" class="headerlink" title="(5) 图像"></a>(5) 图像</h3><ul><li><a href="https://www.stablediffusionai.ai/">SDXL</a> SDXL是Stable Diffusion最新发布的画图模型。这是网友架设的体验站，不需要登陆也不需要付费，直接体验文生图。</li><li><a href="https://huggingface.co/spaces/jbilcke-hf/comic-factory">漫画工厂</a> 一个AI引擎，输入剧情自动产生多种风格漫画（日式、美式等等）。</li><li><a href="https://huggingface.co/spaces/akhaliq/AnimeGANv2">animeganv2</a> 输入一张图片，将其转化为漫画风。</li></ul><h3 id="6-资源"><a href="#6-资源" class="headerlink" title="(6) 资源"></a>(6) 资源</h3><ul><li><a href="https://www.aihub.cn/">AIHUB</a> 该网站收集各种AI工具和资源。</li><li><a href="https://codenews.cc/chatgpt">CHATGPT可用网站</a> ChatGPT的使用页面，并且收集了相关资源。</li><li><a href="https://xinghuo.xfyun.cn/">讯飞星火认知大模型</a></li><li><a href="https://github.com/luban-agi/Awesome-Domain-LLM">Awesome Domain LLM</a> 这个仓库收集各种垂直领域的大语言模型。</li><li><a href="https://chathub.gg/?utm_source=github">allinone插件</a> 一个界面内使用所有chatgpt，当然需要账号登陆才行。</li><li><a href="https://ai.dreamthere.cn/">aidreamthere</a> 该网站收集了各种AI站点，并进行了分类。</li><li><a href="https://github.com/luban-agi/Awesome-AIGC-Tutorials">AIGC</a> 收集各种生成式AI的教程。</li></ul><h3 id="7-股票"><a href="#7-股票" class="headerlink" title="(7) 股票"></a>(7) 股票</h3><ul><li><a href="https://stockai.trade/">stockai.trade</a> 利用GPT进行AI选股。</li></ul><h3 id="8-作文批改"><a href="#8-作文批改" class="headerlink" title="(8) 作文批改"></a>(8) 作文批改</h3><ul><li><a href="https://www.essay.art/ielts">essay.art</a> 使用GPT4对雅思作文和托福作文判分和批改。</li></ul><h3 id="9-聊天"><a href="#9-聊天" class="headerlink" title="(9) 聊天"></a>(9) 聊天</h3><ul><li><a href="https://kagi.com/fastgpt">kagi</a> 一个简易的聊天工具。</li><li><a href="https://www.prettypolly.app/app">PrettyPolly</a> 与AI进行口语练习。</li></ul><h3 id="10-代码生成"><a href="#10-代码生成" class="headerlink" title="(10) 代码生成"></a>(10) 代码生成</h3><ul><li><a href="https://aicodeconvert.com/">AICODETRANSLATOR</a> 该网站可以将一种语言的程序，转换成另一种语言。用户也可以描述想要什么程序，它来生成代码。</li><li><a href="https://www.docstring.ai/">docstring</a> 输入一段代码，给出这段代码的注释，支持多种程序语言。</li></ul><h3 id="11-其他"><a href="#11-其他" class="headerlink" title="(11) 其他"></a>(11) 其他</h3><ul><li><a href="https://www.namedbyai.com/">AI取名</a></li><li><a href="https://www.lepton.ai/playground">lepton</a> 这个网站把开源的AI模型，都做成了云服务，你可以在本地用一行命令调用，也可以在它的网站上试玩这些模型。</li></ul><h2 id="2-计算"><a href="#2-计算" class="headerlink" title="2. 计算"></a>2. 计算</h2><ul><li><a href="https://zh.numberempire.com/">多功能计算器</a> 提供了很多实用的计算器功能。 </li><li><a href="https://www.gigacalculator.com/calculators/statistics/">统计计算器</a> 提供了很多统计相关的计算器功能。</li><li><a href="https://www.wolframalpha.com/">wolframalpha</a> 提供了非常多的自动化问题解决功能，它的工作原理是利用其大量的专家级知识和算法来自动回答问题、进行分析并生成报告。</li></ul><h2 id="3-IP归属地查询"><a href="#3-IP归属地查询" class="headerlink" title="3. IP归属地查询"></a>3. IP归属地查询</h2><ul><li><a href="https://ipinfo.io/">IPINFO</a></li><li><a href="https://ipapi.is/">IPAPI</a></li></ul><h2 id="4-PDF处理"><a href="#4-PDF处理" class="headerlink" title="4. PDF处理"></a>4. PDF处理</h2><ul><li><a href="https://github.com/docusealco/docuseal">docuseal</a> PDF签名</li><li><a href="https://ocrmypdf.readthedocs.io/en/latest/index.html">ocrmypdf</a> PDF ocr工具。</li></ul><h2 id="5-图片处理"><a href="#5-图片处理" class="headerlink" title="5. 图片处理"></a>5. 图片处理</h2><ul><li><a href="https://github.com/zhbhun/idify">IDIFY</a> 将上传的用户照片转为证件照。</li><li><a href="https://github.com/palxiao/poster-design">迅排</a> 开源的在线图片设计器。</li><li><a href="https://github.com/TencentARC/GFPGAN">GFPGAN</a> 开源的老照片修复。</li><li><a href="https://bgsub.cn/">BGSUB</a> 替换照片背景</li><li><a href="https://dunin.itch.io/ptop">paint-of-persia</a> 一款动态像素艺术工具。</li></ul><h2 id="6-资源-1"><a href="#6-资源-1" class="headerlink" title="6. 资源"></a>6. 资源</h2><ul><li><a href="https://github.com/krahets/hello-algo">Hello算法</a> 一本开源的中文电子书籍，介绍数据结构与算法，配有动画图解。</li><li><a href="https://wesmckinney.com/book/">Python数据分析</a></li><li><a href="https://www.deusinmachina.net/p/the-basics-of-arm64-assembly">ARM64汇编语言入门教程</a></li><li><a href="https://makefiletutorial.com/">MakeFile学习</a></li><li><a href="https://github.com/lovefc/china_school_badge">高校校徽字体图标库</a></li><li><a href="https://icongo.github.io/#/">icon</a> 查找图标。</li></ul><h2 id="7-图标"><a href="#7-图标" class="headerlink" title="7. 图标"></a>7. 图标</h2><ul><li><a href="https://yesicon.app/">yesicon</a> 中文的图标搜索引擎，作者利用ChatGPT翻译了Iconify的18万个图标名。</li></ul><h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h2><ul><li><a href="https://krikienoid.github.io/flagwaver/">flagwaver</a> 提供一张图片，可以是网址或者本地文件，会造出旗子飘动的效果。</li><li><a href="https://gifcities.org/">gif收集</a> 这个网站收集了很多gif，支持搜索。</li><li><a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">floatconverter</a> 浮点数在线转换。</li><li><a href="https://tooltt.com/floatconverter/">floatconverter1</a> 又一个浮点数在线转换。</li><li><a href="http://binary-converter.bchrt.com/">floatconverter2</a> 又又一个浮点数在线转换。</li><li><a href="http://www.speedfly.cn/tools/hexconvert/">converter</a> 在线进制转换。</li><li><a href="https://www.haomeili.net/Math/RenYiJinZhiZhuanHuan?From=64&amp;FromBase=64&amp;To=6G&amp;ToBase=62">converter1</a> 又一个在线进制转换。</li><li><a href="https://tool.oschina.net/hexconvert/">converter2</a> 又又一个在线进制转换。</li><li><a href="https://www.toolhelper.cn/">toolhelper</a> 有很多比较实用的在线工具。</li><li><a href="https://evanw.github.io/float-toy/">float-toy</a> 以图片的方式展示浮点进制。</li><li><a href="https://www.jq22.com/textDifference">diff</a> 在线文本比较工具。</li><li><a href="https://www.67tool.com/">67tool</a> 有很多比较实用的在线工具。</li><li><a href="https://setpose.com/">setpose</a> 人体姿势模拟器。</li><li><a href="https://getsimnum.caict.ac.cn/#/">电话卡查询</a> 查询自己名下有多少张电话卡。</li><li><a href="https://pimeyes.com/en">face</a> 查询网络图片出处。</li><li><a href="https://yunmaovideo.com/">yunmao</a> 在线转码工具。</li><li><a href="https://ocr.plantree.me/ocr">weocr</a> 一个图片文字识别的OCR网站，可以离线使用。</li></ul><h2 id="9-聊天-1"><a href="#9-聊天-1" class="headerlink" title="9. 聊天"></a>9. 聊天</h2><ul><li><a href="https://github.com/vasanthv/talk">talk</a> 一个开源的网页聊天工具，非常轻量化。</li></ul><h2 id="10-文章"><a href="#10-文章" class="headerlink" title="10. 文章"></a>10. 文章</h2><ul><li><a href="https://androidblog.a.pinggy.io/">将网站托管在手机上</a></li><li><a href="https://engineering.desmos.com/articles/pratt-parser/">编译器如何解析</a></li></ul><h2 id="11-语言编译器"><a href="#11-语言编译器" class="headerlink" title="11. 语言编译器"></a>11. 语言编译器</h2><ul><li><a href="https://www.jdoodle.com/python3-programming-online/">PYTHON IDE0</a></li><li><a href="https://www.python.org/shell/">PYTHON IDE1</a></li><li><a href="https://c.runoob.com/compile/12/">多语言IDE</a></li><li><a href="https://vscode.dev/">VSCODE在线</a></li><li><a href="https://github.dev/github/dev">VSCODE在线1</a></li><li><a href="https://dexter.uwplse.org/">dexter</a> 将c++代码自动转换为halide代码。</li></ul><h2 id="12-绘图"><a href="#12-绘图" class="headerlink" title="12. 绘图"></a>12. 绘图</h2><ul><li><a href="https://app.diagrams.net/">diagrams</a></li><li><a href="https://pddon.com/">pddon</a> 一个免费的在线绘图软件。</li><li><a href="https://www.composable.art/app">composable</a> 一个在线3D绘图软件。</li><li><a href="https://excalidraw.com/">Excalidraw</a> 手绘风画图软件。</li><li><a href="https://app.diagrams.net/">draw.io</a> 神器，不仅有日常的风格，还有手绘风。</li></ul><h2 id="13-专利"><a href="#13-专利" class="headerlink" title="13. 专利"></a>13. 专利</h2><ul><li><a href="https://pss-system.cponline.cnipa.gov.cn/conventionalSearch">search</a> 专利检索。</li></ul><h2 id="14-社工库"><a href="#14-社工库" class="headerlink" title="14. 社工库"></a>14. 社工库</h2><ul><li><a href="https://zy.xywlapi.cc/">xapi</a></li><li><a href="https://loseprivacy.net/?lp=MjU0ODg1">loseprivacy</a> 泄露数据查询。</li></ul><h2 id="15-文章"><a href="#15-文章" class="headerlink" title="15. 文章"></a>15. 文章</h2><ul><li><a href="https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign">去分支算法</a> </li></ul><h2 id="16-论文"><a href="#16-论文" class="headerlink" title="16. 论文"></a>16. 论文</h2><ul><li><a href="https://consensus.app/">consensus</a> 一个基于AI的科学论文搜索引擎，你问一个问题，它可以从论文中提取答案（英文的），很适合做文献综述。</li></ul><h2 id="17-下载"><a href="#17-下载" class="headerlink" title="17. 下载"></a>17. 下载</h2><ul><li><a href="https://anybt.eth.limo/">AntBT</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;记录一些有趣的网站、工具或者文章。这些信息来源比较广泛，有些比较实用的也许会单独拆出来另外写一篇，有些不太实用（比如waiting list</summary>
      
    
    
    
    
    <category term="闲杂" scheme="http://cakgod.github.io/tags/%E9%97%B2%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>现代微处理器</title>
    <link href="http://cakgod.github.io/2023/01/07/modern-microprocessor/"/>
    <id>http://cakgod.github.io/2023/01/07/modern-microprocessor/</id>
    <published>2023-01-07T02:08:38.000Z</published>
    <updated>2023-10-09T07:05:13.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-参考文章"><a href="#1-参考文章" class="headerlink" title="1. 参考文章"></a>1. 参考文章</h1><p><a href="https://www.lighterra.com/papers/modernmicroprocessors/">Modern Microprocessors. A 90-Minute Guide!</a></p><p>本文绝对是一篇非常好的文章，以本人的垃圾水平暂时只能读懂部分，并且有点看不下去，先挖个坑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-参考文章&quot;&gt;&lt;a href=&quot;#1-参考文章&quot; class=&quot;headerlink&quot; title=&quot;1. 参考文章&quot;&gt;&lt;/a&gt;1. 参考文章&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.lighterra.com/papers/modernmicr</summary>
      
    
    
    
    
    <category term="读后感" scheme="http://cakgod.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    <category term="硬件" scheme="http://cakgod.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>记一次robocup2d比赛</title>
    <link href="http://cakgod.github.io/2022/10/09/robocup-2d/"/>
    <id>http://cakgod.github.io/2022/10/09/robocup-2d/</id>
    <published>2022-10-09T09:12:27.000Z</published>
    <updated>2023-10-09T09:34:12.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在前东家参加了一个robocup2d的比赛，感兴趣的可以搜索一下这个比赛。主要是通过代码控制二维足球员踢球对抗。这篇文章记录一下比赛中的资料和感悟。</p><h1 id="2-详述"><a href="#2-详述" class="headerlink" title="2. 详述"></a>2. 详述</h1><h2 id="2-1-关键问题"><a href="#2-1-关键问题" class="headerlink" title="2.1. 关键问题"></a>2.1. 关键问题</h2><ul><li>无球队员的跑位</li><li>截球问题</li><li>射门技术</li><li>铲球模型</li><li>动作决策搜索</li></ul><h2 id="2-2-仿真模型"><a href="#2-2-仿真模型" class="headerlink" title="2.2. 仿真模型"></a>2.2. 仿真模型</h2><h3 id="2-2-1-感知模型"><a href="#2-2-1-感知模型" class="headerlink" title="2.2.1. 感知模型"></a>2.2.1. 感知模型</h3><ul><li>听觉模型：接受球员、教练喊话，或裁判发送的信息。</li><li>视觉模型：视觉范围和视觉质量。</li><li>身体感知模型：球员自身（位置、速度、身体方向等）。</li></ul><h3 id="2-2-2-运动模型"><a href="#2-2-2-运动模型" class="headerlink" title="2.2.2. 运动模型"></a>2.2.2. 运动模型</h3><ul><li>全局坐标系：以球场中心为（0，0），右边为x轴正方向，长度为52.5；下边为y轴正方向，长度为34.0。</li><li>球员坐标系：以身体方向为y轴正方向。</li></ul><h3 id="2-2-3-动作模型和体能模型"><a href="#2-2-3-动作模型和体能模型" class="headerlink" title="2.2.3. 动作模型和体能模型"></a>2.2.3. 动作模型和体能模型</h3><p>动作包括互斥动作和非互斥动作。</p><ul><li>互斥动作包括：Kick、Dash、Turn、Tackle、Catch、Move</li><li>非互斥动作包括：Say、AttentionTo、PointTo、TurnNeck、ChangeView、Score、SenseBody</li></ul><h3 id="2-2-4-球员异构模型"><a href="#2-2-4-球员异构模型" class="headerlink" title="2.2.4. 球员异构模型"></a>2.2.4. 球员异构模型</h3><p>18种异构类型，每场server随机11种</p><h3 id="2-2-5-裁判模型"><a href="#2-2-5-裁判模型" class="headerlink" title="2.2.5. 裁判模型"></a>2.2.5. 裁判模型</h3><p>判断出界、角球、越位等情形的判断</p><ul><li>Before_kick_off 比赛开始之前</li><li>Play_on 比赛进行中</li><li>Time_over 比赛结束</li><li>Kick_off_side 声明比赛开始</li><li>Kick_in_side</li><li>Free_kick</li><li>Corner_kick_side</li><li>CGoal_kick_side</li><li>Drop_ball</li><li>Offside_side</li><li>Goal_side_n</li><li>Foul_side</li><li>Goalie_catch_ball_side</li><li>Back_pass_side</li><li>Free_kick_fault_side</li><li>Time_up_without_a_team</li><li>Half_time</li><li>Time_up</li><li>Time_extented</li></ul><h2 id="3-阵型设计和跑位"><a href="#3-阵型设计和跑位" class="headerlink" title="3. 阵型设计和跑位"></a>3. 阵型设计和跑位</h2><h3 id="3-1-阵型建模方法"><a href="#3-1-阵型建模方法" class="headerlink" title="3.1. 阵型建模方法"></a>3.1. 阵型建模方法</h3><p>UVA的阵型因子建模、agent2d的Delaunay三角剖分法</p><h3 id="3-2-阵型参数"><a href="#3-2-阵型参数" class="headerlink" title="3.2. 阵型参数"></a>3.2. 阵型参数</h3><ul><li>Formation_id 阵型编号</li><li>Player_num 球员编号，1~11</li><li>Player_role 球员角色</li><li>Player_x 球员初始状态x坐标</li><li>Player_y 球员初始状态y坐标</li><li>Attr_x 球对球员x坐标的吸引因子</li><li>Attr_y 球对球员y坐标的吸引因子</li><li>Behind_ball 是否限制球员位于球的后方</li><li>X_min 球员x坐标的最小值</li><li>X_max 球员x坐标的最大值</li></ul><h3 id="3-3-跑位点"><a href="#3-3-跑位点" class="headerlink" title="3.3. 跑位点"></a>3.3. 跑位点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=min(max(Player_x+(Ball_x*Attr_x), X_min), X_max)</span><br><span class="line">if Behind_ball=True Then x=min(x,Ball_x)</span><br><span class="line">y=Player_y+(Ball_y*Attr_y)</span><br></pre></td></tr></table></figure><p>其中(Ball_x, Ball_y)表示球的位置</p><h2 id="4-代码解读"><a href="#4-代码解读" class="headerlink" title="4. 代码解读"></a>4. 代码解读</h2><h3 id="4-1-librcsc"><a href="#4-1-librcsc" class="headerlink" title="4.1. librcsc"></a>4.1. librcsc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rcsc/action         动作类（重点）   </span><br><span class="line">rcsc/ann            人工神经网络类   </span><br><span class="line">rcsc/coach          在线教练类   </span><br><span class="line">rcsc/common         公共的类   </span><br><span class="line">rcsc/formation      一些阵型类（agent2d只使用了DT跑位）   </span><br><span class="line">rcsc/geom           一些几何类   </span><br><span class="line">rcsc/net            一些与server交换数据的类   </span><br><span class="line">rcsc/param          一些参数类   </span><br><span class="line">rcsc/player         一些球员类（重点）   </span><br><span class="line">rcsc/time           时间类（一般用不到）   </span><br><span class="line">rcsc/trainer        一些离线教练类   </span><br><span class="line">rcsc/util           game_mode math  version</span><br></pre></td></tr></table></figure><h3 id="4-2-src"><a href="#4-2-src" class="headerlink" title="4.2. src"></a>4.2. src</h3><ul><li>以bhv开头的都是在各种情况下的动作执行类（重要）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bhv_basic_move 球员基本跑位</span><br><span class="line">bhv_basic_offensive_kick 基本进攻踢球</span><br><span class="line">bhv_basic_tackle 阻截对手的球（铲球）</span><br><span class="line">bhv_custom_before_kick_off 开球前的习惯（模式）</span><br><span class="line">bhv_go_to_static_ball 跑向静态球</span><br><span class="line">bhv_goalie_basic_move 守门员基本跑位</span><br><span class="line">bhv_goalie_chase_ball 守门员追球</span><br><span class="line">bhv_goalie_free_kick 守门员任意球</span><br><span class="line">bhv_penalty_kick 罚球</span><br><span class="line">bhv_prepare_set_play_kick 准备踢比赛</span><br><span class="line">bhv_set_play_free_kick 设置任意球</span><br><span class="line">bhv_set_play_goal_kick 设置踢球门球</span><br><span class="line">bhv_set_play_indirect_free_kick 设置打间接任意球</span><br><span class="line">bhv_set_play_kick_in 设置踢界外球</span><br><span class="line">bhv_set_play_kick_off 设置开球</span><br><span class="line">bhv_their_goal_kick_move 对手踢球跑位</span><br></pre></td></tr></table></figure><ul><li>以role开头的都是角色类   </li><li>以sample开头的都是示例，可以模仿其结构修改代码       </li><li>以intertion开头的是意图类       </li><li>以neck开头的是转脖子动作</li></ul><h3 id="4-3-formations-dt"><a href="#4-3-formations-dt" class="headerlink" title="4.3. formations-dt"></a>4.3. formations-dt</h3><p>保存了一些阵型的数据</p><h3 id="4-4-chain-action"><a href="#4-4-chain-action" class="headerlink" title="4.4. chain_action"></a>4.4. chain_action</h3><p>agent2d底层的决策核心</p><h3 id="4-5-球员角色分配"><a href="#4-5-球员角色分配" class="headerlink" title="4.5. 球员角色分配"></a>4.5. 球员角色分配</h3><p>具体代码在<code>“ROLE_角色名”</code>中查看；具体角色划分在strategy.cpp里面；异构球员的顺序在<code>sample_coach.cpp</code>里面；具体的阵型角色文件通常以Begin Roles开始，以End Roles结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CenterForward 中锋      （11号）</span><br><span class="line">SideForward   边锋      （9，10号）</span><br><span class="line">SideBack      边后卫    （2，5号）</span><br><span class="line">CenterBack    中后卫    （3，4号）</span><br><span class="line">DefensiveHalf 防守型中场 （6号）</span><br><span class="line">OffensiveHalf 进攻型中场 （7，8号）</span><br></pre></td></tr></table></figure><h3 id="4-6-代码执行流程"><a href="#4-6-代码执行流程" class="headerlink" title="4.6. 代码执行流程"></a>4.6. 代码执行流程</h3><ul><li>由Main()函数开始</li><li>首先是一些环境变量设置，启动球员类。</li><li>进入BasicClient类中，执行Run()函数。</li><li>RunOnline()调用PlayerAgent类的 HandleMessage()函数处理获得的信息。</li><li>HandleMessage()函数调用在PlayerAgent类中的Action()函数进行动作决策和Server参数的解析parse()函数。</li><li>在Action()函数中依次执行ActionImpl()函数，DoArmAction()函数，DoViewAction()函数，DoNeckAction()函数以及CommunicationImpl()函数。</li><li>其中ActionImpl()函数是主要的决策函数的框架。基于球员在场上的角色（Role）以及场上位置（Home Position），执行相应的Role策略，这种基于角色的策略增加了球员的灵活性，使不同类型的球员具有不同的策略，对于球场动态环境具有更强的自适应性。</li></ul><h2 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h2><p>（1）bhv_basic_move.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// agent代表一个智能体 球员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行函数  判断BasicMove是否执行</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Bhv_BasicMove::execute</span><span class="params">( PlayerAgent * agent )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*Logger类：为了输出玩家代理的动作内容，特别是有关决策的记录，</span></span><br><span class="line"><span class="comment">    通过使用Logger，可以在比赛时间的同时将任意消息输出到外部文件，</span></span><br><span class="line"><span class="comment">    可以设置日志级别（具体看开发文档）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// dlog是logger.&#123;h，cpp&#125;中宣布的全局变量，是Logger类的实体。</span></span><br><span class="line">    <span class="comment">// addText（）的第一参数中指定了日志级别的Id</span></span><br><span class="line">    dlog.<span class="built_in">addText</span>( Logger::TEAM,</span><br><span class="line">                  __FILE__<span class="string">&quot;: Bhv_BasicMove&quot;</span> );<span class="comment">//输出TEAM的日志信息</span></span><br><span class="line">    <span class="comment">//-----------------------------------------------</span></span><br><span class="line">    <span class="comment">// tackle拦截（铲球）</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">Bhv_BasicTackle</span>( <span class="number">0.8</span>, <span class="number">80.0</span> ).<span class="built_in">execute</span>( agent ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> WorldModel &amp; wm = agent-&gt;<span class="built_in">world</span>();</span><br><span class="line">    <span class="comment">/*--------------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">// chase ball 追球--&gt;拦截</span></span><br><span class="line">    <span class="comment">// InterceptTable类是根据保存在World Model内的信息，</span></span><br><span class="line">    <span class="comment">// 来预测各玩家捕捉球所需的循环数，并将其结果保存起来的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SelfObject（播放器代理自身）的预测球捕捉周期数。(自己到达球的周期)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> self_min = wm.<span class="built_in">interceptTable</span>()-&gt;<span class="built_in">selfReachCycle</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我方玩家的预测球捕捉周期数中最小的值。（队友到达球的周期）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mate_min = wm.<span class="built_in">interceptTable</span>()-&gt;<span class="built_in">teammateReachCycle</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 敌玩家的预测球捕捉周期数中最小的值。（对手到达球的周期）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> opp_min = wm.<span class="built_in">interceptTable</span>()-&gt;<span class="built_in">opponentReachCycle</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// bool existKickableTeammate() const;</span></span><br><span class="line">    <span class="comment">// 如果队里估计有一个可以踢球的玩家，返回真。</span></span><br><span class="line">    <span class="keyword">if</span> ( ! wm.<span class="built_in">existKickableTeammate</span>()</span><br><span class="line">         &amp;&amp; ( self_min &lt;= <span class="number">3</span></span><br><span class="line">              || ( self_min &lt;= mate_min</span><br><span class="line">                   &amp;&amp; self_min &lt; opp_min + <span class="number">3</span> )</span><br><span class="line">              )</span><br><span class="line">         )</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        dlog.<span class="built_in">addText</span>( Logger::TEAM,</span><br><span class="line">                      __FILE__<span class="string">&quot;: intercept&quot;</span> );</span><br><span class="line">        <span class="comment">// 执行 球员去追逐（截断）球</span></span><br><span class="line">        <span class="built_in">Body_Intercept</span>().<span class="built_in">execute</span>( agent );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转向函数，猜测是拦截成功后调整转向为进攻方向</span></span><br><span class="line">        agent-&gt;<span class="built_in">setNeckAction</span>( <span class="keyword">new</span> <span class="built_in">Neck_OffensiveInterceptNeck</span>() );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取目标点（球）的位置</span></span><br><span class="line">    <span class="type">const</span> Vector2D target_point =</span><br><span class="line">        Strategy::<span class="built_in">i</span>().<span class="built_in">getPosition</span>( wm.<span class="built_in">self</span>().<span class="built_in">unum</span>() );</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 获取冲刺力（冲刺功率）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> dash_power =</span><br><span class="line">        Strategy::<span class="built_in">get_normal_dash_power</span>( wm );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运球时与球的距离</span></span><br><span class="line">    <span class="type">double</span> dist_thr = wm.<span class="built_in">ball</span>().<span class="built_in">distFromSelf</span>() * <span class="number">0.1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调节球与球员之间的距离</span></span><br><span class="line">    <span class="keyword">if</span> ( dist_thr &lt; <span class="number">1.0</span> ) dist_thr = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    dlog.<span class="built_in">addText</span>( Logger::TEAM,</span><br><span class="line">                  __FILE__<span class="string">&quot;: Bhv_BasicMove target=(%.1f %.1f) dist_thr=%.2f&quot;</span>,</span><br><span class="line">                  target_point.x, target_point.y,</span><br><span class="line">                  dist_thr );</span><br><span class="line">                  </span><br><span class="line">    <span class="comment">// debugClient类 会向调试服务器发送信息作为第一个客户端功能的实现</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加球员信息</span></span><br><span class="line">    agent-&gt;<span class="built_in">debugClient</span>().<span class="built_in">addMessage</span>( <span class="string">&quot;BasicMove%.0f&quot;</span>, dash_power );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设定球员行动目标位置.一个周期只能使用一次。</span></span><br><span class="line">    agent-&gt;<span class="built_in">debugClient</span>().<span class="built_in">setTarget</span>( target_point );</span><br><span class="line">    agent-&gt;<span class="built_in">debugClient</span>().<span class="built_in">addCircle</span>( target_point, dist_thr );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( ! <span class="built_in">Body_GoToPoint</span>( target_point, dist_thr, dash_power</span><br><span class="line">                           ).<span class="built_in">execute</span>( agent ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 身体转向球可以联系设置的体力直接冲向球（动作执行）</span></span><br><span class="line">        <span class="built_in">Body_TurnToBall</span>().<span class="built_in">execute</span>( agent );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( wm.<span class="built_in">existKickableOpponent</span>()</span><br><span class="line">         &amp;&amp; wm.<span class="built_in">ball</span>().<span class="built_in">distFromSelf</span>() &lt; <span class="number">18.0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Neck_TurnToBall是将视角对向球，把视线投向下一个循环的预测球位置。</span></span><br><span class="line">        agent-&gt;<span class="built_in">setNeckAction</span>( <span class="keyword">new</span> <span class="built_in">Neck_TurnToBall</span>() );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Neck_TurnToBallOrScan是将视角对向球或者进行扫描球的位置，</span></span><br><span class="line">        <span class="comment">// 也就是说并不清楚球的位置。</span></span><br><span class="line">        <span class="comment">// 当球信息不可靠时，将视线转向下一个循环的预测球位置。</span></span><br><span class="line">        <span class="comment">// 当球信息可靠性高时，环视周围。</span></span><br><span class="line">        <span class="comment">// 如果存在可以踢除自己以外的球的玩家，则考虑球移动的范围，决定是否注意球。</span></span><br><span class="line">        agent-&gt;<span class="built_in">setNeckAction</span>( <span class="keyword">new</span> <span class="built_in">Neck_TurnToBallOrScan</span>() );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）一些类和函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">类</span><br><span class="line">BallObject Ball; 球类</span><br><span class="line">AgentObject agentObject; agent类</span><br><span class="line">PlayerObject Teammates[MAX_TEAMMATES]; 球员类，三个数组存放不同的球员</span><br><span class="line">PlayerObject Opponents[MAX_OPPONENTS];</span><br><span class="line">PlayerObject UnknownPlayers[MAX_TEAMMATES+MAX_OPPONENTS];</span><br><span class="line">Time 时间类（int类型属性：周期数，循环次数）</span><br><span class="line">Circle 圆类（圆心，半径）</span><br><span class="line">Line 直线类（包含三个double属性，分别是直线ay + bx + c = 0的三个系数）</span><br><span class="line">VecPosition 坐标信息类（包含两个double属性，分别对应x轴和y轴的坐标值）</span><br><span class="line">ObjectT 枚举类，包括场上可能出现的对象，例如OBJECT_BALL，OBJECT_GOAL_L，球，左侧球门等等</span><br><span class="line"></span><br><span class="line">函数</span><br><span class="line">可通过WM-&gt; 调用函数</span><br><span class="line">（1）球的坐标位置</span><br><span class="line">getGlobalPosition( ObjectT o ) 获取o的坐标（返回类型VecPosition）</span><br><span class="line">getBallPos() 获取球的坐标（通过调用getGlobalPosition间接完成）</span><br><span class="line">getBallPos().getX() 获取球的x轴坐标</span><br><span class="line">getBallPos().getY() 获取球的y轴坐标（均为double类型）</span><br><span class="line">getPosOwnGoal() 获取自己的球门位置（返回VecPosition）</span><br><span class="line">getPosOpponentGoal( ) 获取对手球门的位置（返回VecPosition）</span><br><span class="line"></span><br><span class="line">（2）球的速度，方向</span><br><span class="line">getGlobalVelocity( ObjectT o ) 获取o的速度（返回类型VecPosition）</span><br><span class="line">getBallSpeed() 获取球的速度（返回值为double类型，通过调用getGlobalVelocity()间接完成）</span><br><span class="line">getBallDirection()获取球的运动方向（返回AngDeg（弧度角），也就是double）</span><br><span class="line"></span><br><span class="line">（3）球员，场上的状态</span><br><span class="line">getPlayerNumber() const 获取球员的号码（返回int）</span><br><span class="line">getPlayMode() 获取状态</span><br><span class="line">PlayModeT 枚举类，包含不同的状态，例如PM_BEFORE_KICK_OFF，PM_KICK_OFF_LEFT</span><br><span class="line">getClosestInSetTo这是一个重载函数，根据参数的不同功能的实现也不同</span><br><span class="line"></span><br><span class="line">（4）距离，角度</span><br><span class="line">getPosClosestOpponentTo( double *dDist, ObjectT o ) （返回VecPosition）</span><br><span class="line">getRelAngleOpponentGoal() 获取自己与对方球门之间的相对角（返回double）</span><br><span class="line">getRelativeDistance( ObjectT o )获取自己与o之间的相对距离（返回double）</span><br><span class="line">getRelDistanceOpponentGoal() 获取自己与对方球门之间的相对距离（返回double）</span><br><span class="line"></span><br><span class="line">（5）判断</span><br><span class="line">isBeforeKickOff( PlayModeT pm ) 判断是否在开球之前（返回bool）</span><br><span class="line">isKickOffUs( PlayModeT pm ) 判断当前的play模式下是否由我方开球</span><br><span class="line">isOffsideUs( PlayModeT pm ) 判断当前的play模式下我方是否越位（返回bool）</span><br><span class="line">isBallKickable() 判断球是否可踢（返回bool）</span><br><span class="line">isBallCatchable() 判断球是否可抓（返回bool，该方法只适用于守门员）</span><br><span class="line">isBallHeadingToGoal( )判断当前球是否朝向我方球门（返回bool）</span><br><span class="line">isBallInOurPossesion( ) 判断球是否在我方手中（返回bool）</span><br><span class="line">isBeforeGoal( VecPosition pos )判断位置参数pos是否在对方球门前（返回bool）</span><br><span class="line"></span><br><span class="line">（6）周期</span><br><span class="line">getCurrentTime() 获取当前的时间（返回Time对象）</span><br><span class="line">getCurrentCycle() 获取当前的周期（返回int）</span><br></pre></td></tr></table></figure><h2 id="6-相关开源项目和开发人员"><a href="#6-相关开源项目和开发人员" class="headerlink" title="6. 相关开源项目和开发人员"></a>6. 相关开源项目和开发人员</h2><ul><li>wrighteaglebase <a href="https://github.com/wrighteagle2d/wrighteaglebase">https://github.com/wrighteagle2d/wrighteaglebase</a> 中科大</li><li>Agent2D <a href="https://github.com/RCSS-IR/StarterAgent2D">https://github.com/RCSS-IR/StarterAgent2D</a></li><li>CYRUS2014 <a href="https://github.com/naderzare/CYRUS2014">https://github.com/naderzare/CYRUS2014</a></li><li>Cyrus2D <a href="https://github.com/Cyrus2D/Cyrus2DBase">https://github.com/Cyrus2D/Cyrus2DBase</a></li><li>helios-base <a href="https://github.com/helios-base/helios-base">https://github.com/helios-base/helios-base</a></li><li>HFO <a href="https://github.com/LARG/HFO">https://github.com/LARG/HFO</a></li><li>Q-Learning_MY_RoboCup2DTeam_Dev <a href="https://github.com/eggegg-wang/Q-Learning_MY_RoboCup2DTeam_Dev">https://github.com/eggegg-wang/Q-Learning_MY_RoboCup2DTeam_Dev</a></li><li>Yunlu <a href="https://github.com/hfuuss/robcup2D_CSU_Yunlu_2020">https://github.com/hfuuss/robcup2D_CSU_Yunlu_2020</a></li><li>Alice <a href="https://github.com/hfuuss/alice">https://github.com/hfuuss/alice</a> 合工大 作者：九月大人 联系方式：ss@hfuusec.cn 489435760</li><li>S3miple <a href="https://github.com/W4xMell/S3miple">https://github.com/W4xMell/S3miple</a></li><li>Oxsy_Core <a href="https://github.com/rc2dcc/Oxsy_Core">https://github.com/rc2dcc/Oxsy_Core</a></li><li>Bilibili开发人员：bcahlit</li><li>比赛二进制收集 <a href="https://github.com/romeoonlinesim/soccer-file">https://github.com/romeoonlinesim/soccer-file</a></li></ul><h2 id="7-修改方向"><a href="#7-修改方向" class="headerlink" title="7. 修改方向"></a>7. 修改方向</h2><ul><li>改阵型，配合fedit2来调整</li><li>动作链</li><li>无球跑位策略</li><li>评估器，难度最大</li><li>角色</li><li>其他：原子动作、行为策略、教练</li></ul><h2 id="8-参考文章"><a href="#8-参考文章" class="headerlink" title="8. 参考文章"></a>8. 参考文章</h2><ul><li><a href="https://www.docin.com/p-2294568740.html">https://www.docin.com/p-2294568740.html</a></li><li><a href="https://i.getshell.cn/2016/07/17/Helios-base%E4%BB%A3%E7%A0%81%E5%AF%BC%E8%AF%BB/">https://i.getshell.cn/2016/07/17/Helios-base%E4%BB%A3%E7%A0%81%E5%AF%BC%E8%AF%BB/</a></li><li><a href="https://i.getshell.cn/2016/07/24/Helios-base%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9/">https://i.getshell.cn/2016/07/24/Helios-base%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9/</a></li></ul><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>比赛给了大家一个月的时间来学习、修改代码，由于种种原因，我们组在前期还取得不错的成绩，但是后期却掉落下来。我们当时大多数的组采用的都是暴力调参，实战对抗，毫无悬念最后也只能在一定范围内提升。动手去修改算法的组还是比较少的。不过有兄弟组采用RL search的方式，使用机器学习模型替代手工调参，最后的确搜索到了很不错的参数组合，最终好像是第一还是第二来着，让人眼前一亮。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;在前东家参加了一个robocup2d的比赛，感兴趣的可以搜索一下这个比赛。主要是通过代码控制二维足球员踢球对抗。这篇文章</summary>
      
    
    
    
    
    <category term="比赛" scheme="http://cakgod.github.io/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>视频防抖</title>
    <link href="http://cakgod.github.io/2022/10/09/video-stabilization/"/>
    <id>http://cakgod.github.io/2022/10/09/video-stabilization/</id>
    <published>2022-10-09T08:42:11.000Z</published>
    <updated>2023-10-09T09:05:06.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>该文章总结了一些视频防抖技术。点播、直播行业的蓬勃发展，使用户生产视频（UGC）逐渐替代了专家生产和平台生产的方式，成为了主流。由于广大用户不可能全都具备专业素质和专业器材，其产出的视频往往质量较差，最明显的特征之一就是存在抖动。视频防抖有很多种技术，各有优劣，主流的目前分为三种：</p><h2 id="1-1-电子图像稳定（Electronic-Image-Stabilization，EIS）"><a href="#1-1-电子图像稳定（Electronic-Image-Stabilization，EIS）" class="headerlink" title="1.1. 电子图像稳定（Electronic Image Stabilization，EIS）"></a>1.1. 电子图像稳定（Electronic Image Stabilization，EIS）</h2><p>俗称电子防抖，是通过软件算法实现防抖的。其技术运作原理是通过加速度传感器和陀螺仪模块侦测手机抖动的幅度，从而来动态调节整ISO、快门以及成像算法来做模糊修正。</p><ul><li>优点：成本低</li><li>缺点：画面会被裁切，牺牲图像分辨率</li></ul><h2 id="1-2-光学图像稳定（Optical-Image-Stabilization，OIS）"><a href="#1-2-光学图像稳定（Optical-Image-Stabilization，OIS）" class="headerlink" title="1.2. 光学图像稳定（Optical Image Stabilization，OIS）"></a>1.2. 光学图像稳定（Optical Image Stabilization，OIS）</h2><p>俗称光学防抖，是通过处理器、陀螺仪和相机防抖模组之间的配合，在拍照抖动时用以驱动防抖组件快速向抖动的相反方向移动镜头模组，由此来抵消发生的抖动，进而实现最终的稳定成像。</p><ul><li>优点：画面不会被裁切，原生画质图像效果最好</li><li>缺点：成本较高、镜头非常容易损坏、镜头无法做小</li></ul><h2 id="1-3-混合图像稳定（Hybrid-Image-Stabilization，HIS）"><a href="#1-3-混合图像稳定（Hybrid-Image-Stabilization，HIS）" class="headerlink" title="1.3. 混合图像稳定（Hybrid Image Stabilization，HIS）"></a>1.3. 混合图像稳定（Hybrid Image Stabilization，HIS）</h2><p>俗称混合防抖，结合了EIS和OIS，是智能手机上的综合防抖技术，集OIS和EIS的所有优点于一身，与其他两种技术相比，防抖能力大幅提升，对有效的HDR和夜间拍摄提供了极好的支持。</p><p>目前，HIS混合防抖技术已在谷歌的Pixel系列、三星Galaxy S21 5G以及iPhone11 Pro Max、iPhone12 Pro Max等高端iPhone系列上使用。</p><ul><li>优点：非常好的防抖，适合需要高曝光的拍摄功能。</li><li>缺点：需要在光学防抖（OIS）和电子防抖（EIS）之间进行优化，成本高。</li></ul><h2 id="1-4-人工智能图像稳定（AI-Image-Stabilization，AIS）"><a href="#1-4-人工智能图像稳定（AI-Image-Stabilization，AIS）" class="headerlink" title="1.4. 人工智能图像稳定（AI Image Stabilization，AIS）"></a>1.4. 人工智能图像稳定（AI Image Stabilization，AIS）</h2><p>俗称AI防抖，是一种基于人工智能的图像防抖技术，可以在相机拍摄过程中，减少因为手抖动造成的画面模糊，获得更加稳定，清晰的画面。即使在拍摄视频或者拍摄夜景时，也可取得良好的防抖效果。</p><ul><li>优点：健壮性可以做到很强</li><li>缺点：性能低、尚未普及</li></ul><h1 id="2-手机防抖调研"><a href="#2-手机防抖调研" class="headerlink" title="2. 手机防抖调研"></a>2. 手机防抖调研</h1><h2 id="2-1-参考文章"><a href="#2-1-参考文章" class="headerlink" title="2.1. 参考文章"></a>2.1. 参考文章</h2><ul><li><a href="https://myfone.blog/smartphone-with-image-stabilization/">文章一</a></li><li><a href="https://www.iwyv.com/shouji/69642.html">文章二</a></li></ul><h2 id="2-2-详情"><a href="#2-2-详情" class="headerlink" title="2.2. 详情"></a>2.2. 详情</h2><div class="table-container"><table><thead><tr><th>型号</th><th>类型</th><th>主打特色</th><th>硬件介绍</th></tr></thead><tbody><tr><td>iphone 14 PM</td><td>OIS</td><td>1、后摄：4800万像素；主摄：第二代传感器位移式光学图像防抖功能，1200万像素；2倍长焦：第二代传感器位移式光学图像防抖功能，1200万像素；3倍长焦：光学图像防抖功能。2、前摄：影院级视频防抖功能 (4K、1080p 和 720p)。3、录像：第二代传感器位移式视频光学图像防抖功能 (主摄) 双摄像头视频光学图像防抖功能 (主摄和长焦)</td><td>将传感器固定在通过电磁效应平行滑动的平台上，利用电磁的迟滞性使传感器在短时间内固定不动，达到防抖的目的。不过，苹果iPhone上的传感器位移式防抖为双轴，仅可抵消X、Y两个反向的抖动，相比目前高端无反相机配备的五轴防抖，有一定的局限性。</td></tr><tr><td>huawei mate 50 pro</td><td>OIS</td><td>1、后摄 5000 万像素超光变摄像头（F1.4-F4 光圈，OIS 光学防抖）6400 万像素潜望式长焦摄像头（F3.5 光圈，OIS 光学防抖）</td><td></td></tr><tr><td>vivo x80 pro</td><td>HIS</td><td>微云台防抖+虚化云台适配算法+人像算法，支持标准防抖（4K）、超级防抖（1080p）、360度地平线防抖。</td><td>搭载的微云台，将摄像头模组做成一个整体，剧烈抖动下，镜片和CMOS传感器始终保持相对静止。沿用五轴VIS视频防抖技术，通过“X轴转动+Y轴转动”的超稳微云台防抖，和 “X轴平移+Y轴平移+Z轴旋转”的电子防抖，实现“五轴视频防抖”效果。</td></tr><tr><td>xiaomi 12s ultra</td><td>OIS</td><td>1、后摄 5000万 1 英寸大底专业主摄 Sony’s IMX989 OIS光学防抖 4800万 潜望式长焦 OIS光学防抖 Zoom EIS防抖 2、录像 视频超级防抖</td><td></td></tr><tr><td>oppo find x5 pro</td><td>OIS</td><td>1、后摄 主摄 5000万像素： f/1.7；FOV 80°；1G6P 镜头；支持 AF；采用闭环对焦马达，支持双 OIS 五轴防抖 2、录像 后置支持视频防抖支持 EIS，4K@60fps/30fps、1080P@60fps/30fps、720P@60fps/30fps 前置支持 视频防抖 1080P/720P@30fps</td></tr></tbody></table></div><h1 id="3-OIS"><a href="#3-OIS" class="headerlink" title="3. OIS"></a>3. OIS</h1><p>TODO</p><h1 id="4-EIS"><a href="#4-EIS" class="headerlink" title="4. EIS"></a>4. EIS</h1><h2 id="4-1-基于图像特征点抖动检测加以纠偏的防抖技术"><a href="#4-1-基于图像特征点抖动检测加以纠偏的防抖技术" class="headerlink" title="4.1. 基于图像特征点抖动检测加以纠偏的防抖技术"></a>4.1. 基于图像特征点抖动检测加以纠偏的防抖技术</h2><p>参考文章：<a href="https://www.cnblogs.com/hyb1/p/16505121.html">文章一</a> <a href="https://www.i4k.xyz/article/weixin_45250844/103447430">文章二</a></p><p>（1）关键点检测</p><p>对每一帧（逐帧）图像做角点检测，也就是将图像上所有的关键点角点识别出来。例如下图的<a href="https://img2022.cnblogs.com/blog/511612/202207/511612-20220722120609670-302553720.png">小祥哥</a>。</p><p>关键点检测算法有很多算法：</p><ul><li>FAST</li><li>Agast</li><li>GFTT</li><li>SimpleBlob</li><li>Affine</li><li>SIFT</li><li>BRISK</li><li>ORB</li><li>MSER</li><li>KAZE</li><li>AKAZE</li></ul><p>（2）仿射变换</p><p>逐一将前后两帧的关键点做比对，计算出两两之间的向量差。如下图<a href="https://img2022.cnblogs.com/blog/511612/202207/511612-20220722121733171-1462027177.png">小祥哥</a>，红色箭头所示方向，即两帧相比对得到的向量方向。</p><p>具体操作如下：<br>【1】先使用OpenCV里的光流法函数calcOpticalFlowPyrLK()函数得到当前帧相对上一帧的所有关键点变化信息；<br>【2】再使用OpenCV里的estimateRigidTransform()函数传入上一个函数的两帧的结果，可以挑选出前后两帧两个2D点集矩阵之间的最佳仿射变换。</p><p>（3）方向抹平</p><p>将第二步算出的最佳仿射变换矩阵数据的整体平均方向，套用低通滤波或者高斯滤波，抹平突变的波峰波谷。</p><p>在OpenCV里面分成单程稳定器（OnePassStabilizer）和双程稳定器（TwoPassStabilizer），且支持设置两种滤波方式：低通滤波（LpMotionStabilizer）和高斯滤波（GaussianMotionFilter）。</p><p>以上图小祥哥的视频为例，帧方向变化<a href="https://img2022.cnblogs.com/blog/511612/202207/511612-20220726144151793-67292696.png">曲线</a>。</p><p>其中，横坐标是时间轴；纵坐标轴是视频基于第一帧的画面的水平方向变化的像素位移量；实线是实际根据光流法计算出来的像素位移量；虚线是使用高斯滤波抹平后的相对较为稳定的像素位移量。</p><p>（4）图像裁切</p><p>使用均值滤波抹平之后的仿射变换矩阵数据对视频帧进行图像变换（缩放、旋转、平移等全放射变换）和裁切。</p><p>在OpenCV里面使用invertAffineTransform()和warpAffine()直接对图像进行仿射变换，得到变换后的图像结果。</p><p>比如说视频这一帧，有检测到明显的左移倾向，那么会调用仿射变换，将原视频帧变成下图这样：</p><p><a href="https://img2022.cnblogs.com/blog/511612/202207/511612-20220726145338226-1421896568.png">图片一</a></p><p><a href="https://img2022.cnblogs.com/blog/511612/202207/511612-20220726145338292-1880066262.png">图片二</a></p><p>注意到，修正后的画面整体逆时针有偏移，出现一些黑边。</p><p>（5）resize</p><p>将裁切后的视频resize回原视频的大小。此步骤涉及到多种BorderMode（边界模式）：</p><ul><li>CONSTANT</li><li>REPLICATE</li><li>REFLECT</li><li>WRAP</li><li>REFLECT_101</li><li>TRANSPARENT</li></ul><h2 id="4-2-融合邻近帧的全帧视频稳定方法OVS"><a href="#4-2-融合邻近帧的全帧视频稳定方法OVS" class="headerlink" title="4.2. 融合邻近帧的全帧视频稳定方法OVS"></a>4.2. 融合邻近帧的全帧视频稳定方法OVS</h2><ul><li><a href="https://arxiv.org/abs/2108.09041">论文地址</a></li><li><a href="https://github.com/Annbless/OVS_Stabilization">代码链接</a></li><li><a href="https://picture.iczhiku.com/weixin/message1630646145615.html">参考文章</a></li></ul><h2 id="4-3-用于3D视频稳定的内容保留扭曲"><a href="#4-3-用于3D视频稳定的内容保留扭曲" class="headerlink" title="4.3. 用于3D视频稳定的内容保留扭曲"></a>4.3. 用于3D视频稳定的内容保留扭曲</h2><p>F. Liu, M. Gleicher, H. Jin, and A. Agarwala, “Content-preserving warps for 3d video stabilization,” ACM Transactions on Graphics, vol. 28, no. 3, pp. 1–9, 2009.</p><h2 id="4-4-子空间视频稳定"><a href="#4-4-子空间视频稳定" class="headerlink" title="4.4. 子空间视频稳定"></a>4.4. 子空间视频稳定</h2><p>F. Liu, M. Gleicher, J. Wang, H. Jin, and A. Agarwala, “Subspace video stabilization,” ACM Transactions on Graphics, vol. 30, no. 1, pp. 1–10, 2011.</p><h2 id="4-5-Codingflow：启用视频编码以实现视频稳定"><a href="#4-5-Codingflow：启用视频编码以实现视频稳定" class="headerlink" title="4.5. Codingflow：启用视频编码以实现视频稳定"></a>4.5. Codingflow：启用视频编码以实现视频稳定</h2><p>S. Liu, M. Li, S. Zhu, and B. Zeng, “Codingflow: Enable video coding for video stabilization,” IEEE Transactions on Image Processing, vol. 26, no. 7, pp. 3291–3302, 2017.</p><h2 id="4-6-转换空间中的测地线视频稳定"><a href="#4-6-转换空间中的测地线视频稳定" class="headerlink" title="4.6. 转换空间中的测地线视频稳定"></a>4.6. 转换空间中的测地线视频稳定</h2><p>L. Zhang, X.-Q. Chen, X.-Y. Kong, and H. Huang, “Geodesic video stabilization in transformation space,” IEEE Transactions on Image Processing, vol. 26, no. 5, pp. 2219–2229, 2017.</p><h2 id="4-7-自拍视频防抖"><a href="#4-7-自拍视频防抖" class="headerlink" title="4.7. 自拍视频防抖"></a>4.7. 自拍视频防抖</h2><p>J. Yu and R. Ramamoorthi, “Selfie video stabilization,” in Proceedings of the European Conference on Computer Vision, 2018, pp. 551–566.</p><h1 id="5-AIS算法解析"><a href="#5-AIS算法解析" class="headerlink" title="5. AIS算法解析"></a>5. AIS算法解析</h1><h2 id="5-1-DUT：通过简单地观看不稳定的视频来学习视频稳定"><a href="#5-1-DUT：通过简单地观看不稳定的视频来学习视频稳定" class="headerlink" title="5.1. DUT：通过简单地观看不稳定的视频来学习视频稳定"></a>5.1. DUT：通过简单地观看不稳定的视频来学习视频稳定</h2><ul><li><a href="https://arxiv.org/pdf/2011.14574v3.pdf">论文地址</a></li><li><a href="https://github.com/Annbless/DUTCode">代码链接</a></li></ul><p>简介：<br>过去基于深度学习的视频稳定器需要大量配对的不稳定和稳定视频进行训练，这些视频很难收集。另一方面，传统的基于轨迹的稳定器将任务分为几个子任务并随后处理它们，这些子任务在无纹理和遮挡区域中对于手工特征的使用很脆弱。在本文中，我们尝试以深度无监督学习的方式解决视频稳定问题，该方法借鉴了传统稳定器的分而治之思想，同时利用DNN的表示能力来应对现实世界场景中的挑战。从技术上讲，DUT由轨迹估计阶段和轨迹平滑阶段组成。在轨迹估计阶段，我们首先估计关键点的运动，分别通过新的多单应性估计策略和运动细化网络初始化和细化网格的运动，并通过时间关联获得基于网格的轨迹。在轨迹平滑阶段，我们设计了一种新颖的网络来预测动态平滑内核以实现平滑轨迹，该网络可以很好地适应具有不同动态模式的轨迹。我们利用关键点和网格顶点的空间和时间一致性来制定训练目标，从而形成无监督的训练方案。公共基准的实验结果表明，DUT在质量和数量上都优于最先进的方法。源代码可在 <a href="https://github.com/Annbless/DUTCode">https://github.com/Annbless/DUTCode</a> 获得。</p><h2 id="5-2-具有多网格翘曲变换学习的深度在线视频稳定"><a href="#5-2-具有多网格翘曲变换学习的深度在线视频稳定" class="headerlink" title="5.2. 具有多网格翘曲变换学习的深度在线视频稳定"></a>5.2. 具有多网格翘曲变换学习的深度在线视频稳定</h2><p>M. Wang, G.-Y. Yang, J.-K. Lin, S.-H. Zhang, A. Shamir, S.-P. Lu, and S.-M. Hu, “Deep online video stabilization with multi-grid warping transformation learning,” IEEE Transactions on Image Processing, vol. 28, no. 5, pp. 2283–2292, 2018.</p><h2 id="5-3-Pwstablenet：学习用于视频稳定的像素级翘曲图"><a href="#5-3-Pwstablenet：学习用于视频稳定的像素级翘曲图" class="headerlink" title="5.3. Pwstablenet：学习用于视频稳定的像素级翘曲图"></a>5.3. Pwstablenet：学习用于视频稳定的像素级翘曲图</h2><p>M. Zhao and Q. Ling, “Pwstablenet: Learning pixel-wise warping maps for video stabilization,” IEEE Transactions on Image Processing, vol. 29, pp. 3582–3595, 2020.</p><h2 id="5-4-使用对抗网络的深度视频稳定"><a href="#5-4-使用对抗网络的深度视频稳定" class="headerlink" title="5.4. 使用对抗网络的深度视频稳定"></a>5.4. 使用对抗网络的深度视频稳定</h2><p>S.-Z. Xu, J. Hu, M. Wang, T.-J. Mu, and S.-M. Hu, “Deep video stabilization using adversarial networks,” in Computer Graphics Forum, vol. 37, no. 7. Wiley Online Library, 2018, pp. 267–276.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;该文章总结了一些视频防抖技术。点播、直播行业的蓬勃发展，使用户生产视频（UGC）逐渐替代了专家生产和平台生产的方式，成为</summary>
      
    
    
    
    
    <category term="视频" scheme="http://cakgod.github.io/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>分支对性能的影响以及分支优化</title>
    <link href="http://cakgod.github.io/2022/10/07/branch-and-optimization/"/>
    <id>http://cakgod.github.io/2022/10/07/branch-and-optimization/</id>
    <published>2022-10-07T06:06:06.000Z</published>
    <updated>2023-10-09T07:04:41.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-参考文章"><a href="#1-参考文章" class="headerlink" title="1. 参考文章"></a>1. 参考文章</h1><p><a href="https://johnnysswlab.com/how-branches-influence-the-performance-of-your-code-and-what-can-you-do-about-it/">How branches influence the performance of your code and what can you do about it?</a></p><h1 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h1><p>本文属于上述参考文章的一篇读后感，该文章讲了一些关于分支对于软件性能的影响，以及如何通过优化代码中的分支来提高性能。因为之前的工作中也涉及到类似的工作，顺路在这里重新学习并总结一下。</p><h1 id="3-详述"><a href="#3-详述" class="headerlink" title="3. 详述"></a>3. 详述</h1><p>分支（branch，jump）是非常常见的指令类型之一。根据统计，平均每五条指令就要遇到一条分支指令。对于CPU来说，有效的分支实现对于良好的性能至关重要。</p><h2 id="3-1-CPU相关的知识"><a href="#3-1-CPU相关的知识" class="headerlink" title="3.1. CPU相关的知识"></a>3.1. CPU相关的知识</h2><p>许多现代处理器（但不是全部，特别是嵌入式系统中使用的一些处理器）都具有以下部分或全部功能： </p><ul><li><p><em>流水线（pipeline）</em>：流水线允许CPU同时执行多条指令。CPU将每条指令的执行分为几个阶段，并且每条指令处于不同的执行阶段。汽车工厂也采用同样的原理：在任何给定时间，工厂同时生产五十辆汽车，例如，一辆汽车正在喷漆，另一辆汽车正在安装发动机，第三辆汽车正在安装车灯，流水线可以很短，只有几个阶段（例如三个阶段），也可以很长，有很多阶段（例如二十个阶段）。</p></li><li><p><em>乱序执行（OOE，out of order exexcution）</em>：从程序员的角度来看，程序运行一条又一条指令。在CPU中情况看起来完全不同：CPU不需要按照指令在内存中出现的顺序来执行它们。在执行过程中，一些指令会被阻塞在CPU中等待来自内存的数据或者等待来自其他指令的数据。CPU可以向前看并执行稍后出现但不会被阻塞的指令。当被阻止的指令的数据变得可用时，之前未被阻止的指令已经完成。这可以节省CPU指令执行周期。</p></li><li><p><em>推断执行（speculative exexcution）</em>：即使不能100%确定需要执行指令，CPU也可以开始执行指令。例如，它会猜测条件分支指令的目的地，然后在100%确定会采用分支之前开始执行分支目的地的指令。如果后来CPU发现猜测（推断）是错误的，它将取消推断执行指令的结果，并且一切都将显示为没有进行任何推断。</p></li><li><p><em>分支预测（branch prediction）</em>：现代CPU具有特殊电路，每个分支指令都会记住其先前的结果：采用分支或未采用分支。当下次执行相同的分支指令时，CPU将使用该信息来猜测分支的目的地，然后在分支目的地开始推断执行指令。如果分支预测器正确，这将导致性能加速。</p></li></ul><p>所有现代处理器都具有pipeline，以便更好地利用CPU资源。并大多数都有分支预测和推断执行。就乱序执行而言，大多数低端低功耗处理器不具备此功能，因为它消耗大量电量且速度提升并不大。</p><h2 id="3-2-CPU处理分支的几种方法"><a href="#3-2-CPU处理分支的几种方法" class="headerlink" title="3.2. CPU处理分支的几种方法"></a>3.2. CPU处理分支的几种方法</h2><p>当分支指令进入处理器流水线时，在对其进行解码并计算其目的地之前，分支目的地是未知的。分支指令之后的指令可以是：直接跟随分支的指令或分支目的地处的指令。CPU对于分支指令的处理可以有三种方式：</p><ul><li><p><em>暂停流水线（pause pipeline，stall pipeline）</em>：暂停流水线并停止解码指令，直到分支指令被解码并且知道分支目的地。然后它可以使用正确的指令恢复加载流水线。</p></li><li><p>加载紧随分支之后的指令。万一后来发现这是错误的选择，处理器将需要刷新流水线并开始从分支目的地加载正确的指令。 </p></li><li><p>询问分支预测器是否应该加载紧接在分支之后的指令或分支目的地处的指令。分支预测器还需要告诉流水线分支目的地在哪里（否则将新指令加载到流水线中并将需要等待流水线解析分支目的地）。</p></li></ul><p>采用第一种方式的处理器现在很少见，除了一些非常低端的嵌入式处理器，仅仅让处理器什么都不做就是浪费资源。因此大多数处理器会执行采用第二种方式，常见于低端嵌入式系统和低功耗处理器。采用第三种方式的处理器是常见的台式机和笔记本电脑CPU以及高性能CPU。</p><h2 id="3-3-分支对于性能的影响"><a href="#3-3-分支对于性能的影响" class="headerlink" title="3.3. 分支对于性能的影响"></a>3.3. 分支对于性能的影响</h2><p>主要介绍以下两点影响：</p><ul><li><p>在某些处理器上，指令自上而下“贯穿”（fall through）的开销远远小于分支指令的开销。</p></li><li><p>自动向量化（auto vectorization）是现代处理器中比较常用的提高性能的手段，分支的加入通常导致代码无法向量化。</p></li></ul><h2 id="3-4-分支优化手段"><a href="#3-4-分支优化手段" class="headerlink" title="3.4. 分支优化手段"></a>3.4. 分支优化手段</h2><p>本文重点不在于介绍分支预测，而是较少如何优化代码达到去分支或减少分支来提高软件性能。</p><h3 id="3-4-1-优化连接条件（join-condition）"><a href="#3-4-1-优化连接条件（join-condition）" class="headerlink" title="3.4.1. 优化连接条件（join condition）"></a>3.4.1. 优化连接条件（join condition）</h3><p>连接条件是<code>(cond1 &amp;&amp; cond2)</code>或<code>(cond1 || cond2)</code>类型的条件。根据C和C++标准，在<code>(cond1 &amp;&amp; cond2)</code>的情况下，如果<code>cond1</code>为<code>false</code>，则不会评估<code>cond2</code>。类似地，在<code>(cond1 || cond2)</code>的情况下，如果<code>cond1</code>为<code>true</code>，则不会评估<code>cond2</code>。</p><h3 id="3-4-2-优化if-else结构"><a href="#3-4-2-优化if-else结构" class="headerlink" title="3.4.2. 优化if&#x2F;else结构"></a>3.4.2. 优化if&#x2F;else结构</h3><p>以如下代码为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0</span>) &#123; </span><br><span class="line">   <span class="built_in">do_something_else</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">do_something_yet_else</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在考虑<code>(a &lt; 0)</code>的概率为70%，<code>(a &gt; 0)</code>为20%，<code>(a == 0)</code>为10%。在这种情况下，重新排列上述代码是最合乎逻辑的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="built_in">do_something_yet_else</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123; </span><br><span class="line">   <span class="built_in">do_something</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">do_something_else</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-3-使用查找表替换switch语句"><a href="#3-4-3-使用查找表替换switch语句" class="headerlink" title="3.4.3. 使用查找表替换switch语句"></a>3.4.3. 使用查找表替换switch语句</h3><p>在删除分支时，查找表（lookup table, LUT）有时会很方便。不幸的是，在switch语句中，分支在大多数情况下很容易预测，因此这种优化可能不会产生任何效果。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY: <span class="keyword">return</span> <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY: <span class="keyword">return</span> <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">case</span> SUNDAY: <span class="keyword">return</span> <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的语句可以使用LUT来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (day &lt; MONDAY || day &gt; SUNDAY) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">char</span>* days_to_string = &#123; <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, ... , <span class="string">&quot;Sunday&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">return</span> days_to_string[day - MONDAY];</span><br></pre></td></tr></table></figure><p>通常，编译器可以通过用查找表替换开关来为完成这项工作。</p><h3 id="3-4-4-将最常见的情况移出switch语句"><a href="#3-4-4-将最常见的情况移出switch语句" class="headerlink" title="3.4.4. 将最常见的情况移出switch语句"></a>3.4.4. 将最常见的情况移出switch语句</h3><p>如果使用switch命令并且其中一种情况似乎最常见，可以将其移出switch并给予特殊处理。继续上一节的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">day <span class="title">get_first_workday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::chrono::weekday first_workday = <span class="built_in">read_first_workday</span>();</span><br><span class="line">    <span class="keyword">if</span> (first_workday == Monday) &#123; <span class="keyword">return</span> day::Monday; &#125;</span><br><span class="line">    <span class="keyword">switch</span>(first_workday) &#123; </span><br><span class="line">        <span class="keyword">case</span> Tuesday: <span class="keyword">return</span> day::Tueasday;</span><br><span class="line">        ....</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-5-重写连接条件"><a href="#3-4-5-重写连接条件" class="headerlink" title="3.4.5. 重写连接条件"></a>3.4.5. 重写连接条件</h3><p>如前所述，在连接条件的情况下，如果第一个条件具有特定值，则根本不需要评估第二个条件。编译器是如何做到这一点的？以下面的函数为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i] &gt; x &amp;&amp; a[i] &lt; y) &#123;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设<code>a[i] &gt; x</code>和<code>a[i] &lt; y</code>评估起来很便宜（所有数据都在寄存器或缓存中）但难以预测。该序列将转换为以下伪汇编程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if_not (a[i] &gt; x) <span class="keyword">goto</span> ENDIF;</span><br><span class="line">if_not (a[i] &lt; y) <span class="keyword">goto</span> ENDIF;</span><br><span class="line">do_something;</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure><p>这里有两个难以预测的分支。如果我们用<code>&amp;</code>而不是<code>&amp;&amp;</code>连接两个条件，我们将：</p><ul><li>强制同时评估两个条件：<code>&amp;</code>运算符是算术<code>AND</code>运算，并且必须评估两边。</li><li>使条件更容易预测，从而降低分支误预测率：两个完全独立的条件（概率为50%）将产生一个联合条件（概率为25%）。</li><li>摆脱一个分支：我们将拥有一个更容易预测的分支，而不是原来的两个分支。</li></ul><p>运算符<code>&amp;</code>评估这两个条件，并且在生成的程序集中将只有一个分支而不是两个。同样的情况也适用于运算符<code>||</code>及其孪生运算符<code>|</code>。<br>请注意：根据C++标准，bool类型的值为0表示false，任何其他值表示true。C++标准保证逻辑运算和算术比较的结果始终为零或一，但不能保证所有布尔值都只有这两个值。您可以通过应用<code>!!</code>来标准化<code>bool</code>变量其上的操作。</p><h3 id="3-4-6-向编译器建议哪个分支概率更高"><a href="#3-4-6-向编译器建议哪个分支概率更高" class="headerlink" title="3.4.6. 向编译器建议哪个分支概率更高"></a>3.4.6. 向编译器建议哪个分支概率更高</h3><p>GCC和CLANG提供了关键字，程序员可以使用这些关键字来告诉他们哪些分支具有更高的概率。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x)      __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x)    __builtin_expect(!!(x), 0)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">likely</span>(ptr)) &#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们通过可能和不太可能的宏使用<code>__builtin_expect</code>，因为它们的语法在任何地方使用都很麻烦。当这样注释时，编译器将重新排列if和else分支中的指令，以便最优化地使用底层硬件。请确保条件概率正确，否则性能可能会下降。</p><h3 id="3-4-7-使用无分支算法"><a href="#3-4-7-使用无分支算法" class="headerlink" title="3.4.7. 使用无分支算法"></a>3.4.7. 使用无分支算法</h3><p>一些用分支表达的算法可以转换为无分支算法。例如，下面的函数<code>abs</code>使用一种技巧来计算数字的绝对值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> mask = a &gt;&gt; <span class="built_in">sizeof</span>(<span class="type">int</span>) * CHAR_BIT - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (a + mask) ^ mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-8-使用条件加载而不是分支"><a href="#3-4-8-使用条件加载而不是分支" class="headerlink" title="3.4.8. 使用条件加载而不是分支"></a>3.4.8. 使用条件加载而不是分支</h3><p>许多CPU支持可用于删除分支的条件移动指令。这是一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以重写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> new_x = x + <span class="number">1</span>;</span><br><span class="line">x = (x &gt; y) ? new_x : x; <span class="comment">// the compiler should recognize this and emit a conditional branch</span></span><br></pre></td></tr></table></figure><p>编译器应该认识到第2行的命令可以写为变量<code>x</code>的条件加载并发出条件移动指令。不幸的是，编译器对于何时发出条件分支有自己的内部逻辑，这并不总是像开发人员所期望的那样。但是，可以使用内联汇编来强制条件加载。</p><h3 id="3-4-9-通过算术实现无分支"><a href="#3-4-9-通过算术实现无分支" class="headerlink" title="3.4.9. 通过算术实现无分支"></a>3.4.9. 通过算术实现无分支</h3><p>有一种方法可以通过巧妙地使用算术运算来实现无分支。条件增量示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With branch</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    x += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Branchless</span></span><br><span class="line">x += -(a &gt; b) &amp; y; </span><br></pre></td></tr></table></figure><p>在上面的示例中，表达式<code>-(a &gt; b)</code>将创建一个掩码，当条件为假时，该掩码为0；当条件为真时，该掩码全为1。</p><p>条件赋值的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With branch</span></span><br><span class="line">x = (a &gt; b) ? val_a : val_b;</span><br><span class="line"><span class="comment">// Branchless</span></span><br><span class="line">x = val_a;</span><br><span class="line">x += -(a &gt; b) &amp; (val_b - val_a);</span><br></pre></td></tr></table></figure><p>在循环缓冲区中移动索引的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With branch</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_next_element</span><span class="params">(<span class="type">int</span> current, <span class="type">int</span> buffer_len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (next == buffer_len) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Branchless</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_next_element_branchless</span><span class="params">(<span class="type">int</span> current, <span class="type">int</span> buffer_len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (next &lt; buffer_len) * next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-10-重新组织代码以避免分支"><a href="#3-4-10-重新组织代码以避免分支" class="headerlink" title="3.4.10. 重新组织代码以避免分支"></a>3.4.10. 重新组织代码以避免分支</h3><p>假设您有一个名为<code>animation</code>的类，它可以是可见的也可以是隐藏的。处理可见<code>animation</code>与处理隐藏<code>animation</code>有很大不同。有一个包含名为<code>animation_list</code>的<code>animation</code>的列表，处理如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> animation&amp; a: animation_list) &#123;</span><br><span class="line">    a.<span class="built_in">step_a</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">is_visible</span>()) &#123;</span><br><span class="line">        a.<span class="built_in">step_av</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">step_b</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.is_visible) &#123;</span><br><span class="line">        a.<span class="built_in">step_bv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非<code>animation</code>根据可见性进行排序，否则分支预测器确实很难处理上述代码。有两种方法可以解决这个问题。一是根据<code>is_visible()</code>对<code>animation_list</code>中的动画进行排序。第二种是创建两个列表，<code>animation_list_visible</code>和<code>animation_list_hidden</code>，并重写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> animation&amp; a: animation_list_visible) &#123;</span><br><span class="line">    a.<span class="built_in">step_a</span>();</span><br><span class="line">    a.<span class="built_in">step_av</span>();</span><br><span class="line">    a.<span class="built_in">step_b</span>();</span><br><span class="line">    a.<span class="built_in">step_bv</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> animation&amp; a: animation_list_hidden) &#123;</span><br><span class="line">    a.<span class="built_in">step_a</span>();</span><br><span class="line">    a.<span class="built_in">step_b</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的条件都消失了，并且没有分支错误预测。</p><h3 id="3-4-11-使用模板删除分支"><a href="#3-4-11-使用模板删除分支" class="headerlink" title="3.4.11. 使用模板删除分支"></a>3.4.11. 使用模板删除分支</h3><p>如果将布尔值传递给函数并且在函数内部将其用作参数，则可以通过将其作为模板参数传递来删除它。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">average</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> len, <span class="type">bool</span> include_negatives)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> average = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (include_negatives) &#123;</span><br><span class="line">            average += array[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                average += array[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (include_negatives) &#123;</span><br><span class="line">         <span class="keyword">return</span> average / len;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> average / count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此函数中，可以多次评估<code>include_negatives</code>的条件。要删除评估，请将参数作为模板参数而不是函数参数传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> include_negatives&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">average</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> average = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (include_negatives) &#123;</span><br><span class="line">            average += array[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                average += array[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (include_negatives) &#123;</span><br><span class="line">         <span class="keyword">return</span> average / len;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> average / count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过此实现，编译器将生成该函数的两个版本，一种带有<code>include_negatives</code>，一种不带有<code>include_negatives</code>（以防调用此参数具有不同值的函数）。分支完全消失了，未使用的分支中的代码也消失了。</p><p>但现在需要以不同的方式调用您的函数。所以会这样称呼它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> avg;</span><br><span class="line"><span class="type">bool</span> should_include_negatives = <span class="built_in">get_should_include_negatives</span>();</span><br><span class="line"><span class="keyword">if</span> (should_include_negatives) &#123;</span><br><span class="line">    avg = <span class="built_in">average</span>&lt;<span class="literal">true</span>&gt;(array, len);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    avg = <span class="built_in">average</span>&lt;<span class="literal">false</span>&gt;(array, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上是一种称为<code>branch optimization</code>的编译器优化。如果<code>include_negatives</code>的值在编译时已知并且编译器决定内联函数平均值，它将删除分支和未使用的代码。然而，带有模板的版本保证了这一点，而原始版本则不然。</p><p>编译器通常可以进行这种优化。如果编译器可以保证值<code>include_negatives</code>在循环执行期间不会更改其值，则它可以创建两个版本的循环：一种用于其值为<code>true</code>的情况，另一种用于其值为<code>false</code>的情况。这种优化称为循环不变代码优化。</p><h3 id="3-4-12-避免分支的其他一些技巧"><a href="#3-4-12-避免分支的其他一些技巧" class="headerlink" title="3.4.12. 避免分支的其他一些技巧"></a>3.4.12. 避免分支的其他一些技巧</h3><p>如果在代码中多次检查不可更改的条件，则通过检查一次然后进行一些代码复制可能会获得更好的性能。因此，在下面的示例中，两个分支可以替换为一个分支。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_visible) &#123;</span><br><span class="line">    <span class="built_in">hide</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">process</span>();</span><br><span class="line"><span class="keyword">if</span> (is_visible) &#123;</span><br><span class="line">    <span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以替换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_visible) &#123;</span><br><span class="line">    <span class="built_in">hide</span>();</span><br><span class="line">    <span class="built_in">process</span>();</span><br><span class="line">    <span class="built_in">display</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以引入一个两元素数组，一个用于在条件为<code>true</code>时保存结果，另一个用于在条件为<code>false</code>时保存结果。一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> larger = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; m) &#123;</span><br><span class="line">        larger++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> larger;</span><br></pre></td></tr></table></figure><p>可以替换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result[] = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result[a&gt;i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h2 id="3-5-实验"><a href="#3-5-实验" class="headerlink" title="3.5. 实验"></a>3.5. 实验</h2><p>作者在“AMD A8-4500M quad-core x86-64” ，“Allwinner sun7i A20 dual-core ARMv7”和“Ingenic JZ4780 dual-core MIPS32r2”三种处理器上进行了多组对照试验，具体细节暂不描述，结论如下：</p><p>分支推测打破了一些数据依赖性，并有效地掩盖了CPU需要等待内存数据的时间。如果分支预测器的猜测是正确的，那么当数据从内存到达时，很多工作就已经完成了。对于无分支的代码来说，情况并非如此。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-参考文章&quot;&gt;&lt;a href=&quot;#1-参考文章&quot; class=&quot;headerlink&quot; title=&quot;1. 参考文章&quot;&gt;&lt;/a&gt;1. 参考文章&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://johnnysswlab.com/how-branches-influ</summary>
      
    
    
    
    
    <category term="优化" scheme="http://cakgod.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
    <category term="读后感" scheme="http://cakgod.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>编译器中的优化方法</title>
    <link href="http://cakgod.github.io/2021/05/10/compiler-optimization/"/>
    <id>http://cakgod.github.io/2021/05/10/compiler-optimization/</id>
    <published>2021-05-10T01:30:01.000Z</published>
    <updated>2023-10-09T07:34:18.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文总结一下编译器中常见的编译器优化方法，可能有些方法并没有解释特别详细（原理比较简单），有些方法也可能比较复杂，会在另外的文章中详细介绍。</p><h1 id="2-详述"><a href="#2-详述" class="headerlink" title="2. 详述"></a>2. 详述</h1><h2 id="2-1-常量传播"><a href="#2-1-常量传播" class="headerlink" title="2.1. 常量传播"></a>2.1. 常量传播</h2><p>常量传播，就是说在编译期时，能够直接计算出结果（这个结果往往是常量）的变量，将被编译器由直接计算出的结果常量来替换这个变量。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例种，编译器会直接用常量1替换变量x，优化成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="number">1</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-常量折叠"><a href="#2-2-常量折叠" class="headerlink" title="2.2. 常量折叠"></a>2.2. 常量折叠</h2><p>常量折叠，就是说在编译期间，如果有可能，多个变量的计算可以最终替换为一个变量的计算，通常是多个变量的多级冗余计算被替换为一个变量的一级计算。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> x = a + b;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量折叠优化后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，可以再进行进一步的常量替换优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="number">3</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-复写传播"><a href="#2-3-复写传播" class="headerlink" title="2.3. 复写传播"></a>2.3. 复写传播</h2><p>复写传播，就是编译器用一个变量替换两个或多个相同的变量。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x = y;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例有两个变量y和x，但是其实是两个相同的变量，并且其它地方并未区分它们两个，所以它们是重复的，可称为“复写”，编译器可以将其优化，将x“传播”给y，只剩下一个变量x，当然，反过来优化掉x只剩下一个y也是可以的。</p><h2 id="2-4-公共子表式消除"><a href="#2-4-公共子表式消除" class="headerlink" title="2.4. 公共子表式消除"></a>2.4. 公共子表式消除</h2><p>公共子表达式消除是说，如果一个表达式E已经计算过了，并且从先前的计算到现在的E中的变量都没有发生变化，那么E的此次出现就成为了公共子表达式，因此，编译器可判断其不需要再次进行计算浪费性能。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> x = (a+b) * <span class="number">2</span> + (b+a) * <span class="number">6</span>;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> E = a + b;</span><br><span class="line">    <span class="type">int</span> x = E * <span class="number">2</span> + E * <span class="number">6</span>;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也有可能会直接变成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> E = a + b;</span><br><span class="line">    <span class="type">int</span> x = E * <span class="number">8</span>;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-无用代码消除"><a href="#2-5-无用代码消除" class="headerlink" title="2.5. 无用代码消除"></a>2.5. 无用代码消除</h2><p>无用代码消除指的是永远不能被执行到的代码或者没有任何意义的代码会被清除掉，比如return之后的语句，变量自己给自己赋值等等。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x = x;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，x变量自我赋值显然是无用代码，将会被优化掉：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-数组范围检查消除"><a href="#2-6-数组范围检查消除" class="headerlink" title="2.6. 数组范围检查消除"></a>2.6. 数组范围检查消除</h2><p>如果开发语言是Java这种动态类型安全型的，那在访问数组时比如array[ ]时，Java不会像C&#x2F;C++那样只是存粹的裸指针访问，而是会在运行时访问数组元素前进行一次是否越界检查，这将会带来许多开销，如果即时编译器能根据数据流分析出变量的取值范围在[0,array.length]之间，那么在循环期间就可以把数组的上下边界检查消除，以减少不必要的性能损耗。</p><h2 id="2-7-方法内联"><a href="#2-7-方法内联" class="headerlink" title="2.7. 方法内联"></a>2.7. 方法内联</h2><p>这种优化方法是将比较简短的函数或者方法代码直接粘贴到其调用者中，以减少函数调用时的开销，比较重要且常用，很容易理解，就比如C++的inline关键字一样，只不过inline是开发者的手动方法内联，而编译器在分析代码和数据流之后，也有可能做出自动inline的优化。</p><h2 id="2-8-逃逸分析"><a href="#2-8-逃逸分析" class="headerlink" title="2.8. 逃逸分析"></a>2.8. 逃逸分析</h2><p>一个对象如果被其声明的方法之外的一个或多个函数所引用，那就被称为逃逸，可以通俗理解为，该对象逃逸了其原本的命名空间或者作用域，使得声明（或者定义）该对象的方法结束时，该对象不能被销毁。</p><p>通常，一个函数里的局部变量其内存空间是在栈上分配的，而对象则是在堆上分配的内存空间，在函数调用结束时，局部变量会随着栈空间销毁而自动销毁，但堆上的空间要么是依赖类似JVM的垃圾内存自动回收机制（GC），要么就得像C&#x2F;C++那样的依赖开发者本身的记忆力，因此，堆上的内存分配与销毁一般开销会比栈上的大得多。</p><p>逃逸分析的基本原理就是分析对象动态作用域。如果确定一个方法不会逃逸出方法之外，那让整个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧而销毁。在一般应用中，不会逃逸的局部对象所占用的比例很大，如果能在编译器优化时，为其在栈上分配内存空间，那大量的对象就会随着方法结束而自动销毁了，不用依赖前面讲的GC或者记忆力，系统的压力将会小很多。</p><h2 id="2-9-分支优化"><a href="#2-9-分支优化" class="headerlink" title="2.9. 分支优化"></a>2.9. 分支优化</h2><p>分支通常会严重影响程序性能，对于分支如何对程序产生影响以及如何优化分支，可以参考我的另外一篇<a href="https://cakgod.github.io/2022/10/07/branch-and-optimization/">博客</a>。</p><h2 id="2-10-循环优化"><a href="#2-10-循环优化" class="headerlink" title="2.10. 循环优化"></a>2.10. 循环优化</h2><p>TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;本文总结一下编译器中常见的编译器优化方法，可能有些方法并没有解释特别详细（原理比较简单），有些方法也可能比较复杂，会在另</summary>
      
    
    
    
    
    <category term="优化" scheme="http://cakgod.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
    <category term="编译器" scheme="http://cakgod.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>图像算法</title>
    <link href="http://cakgod.github.io/2021/02/18/image-algorithm/"/>
    <id>http://cakgod.github.io/2021/02/18/image-algorithm/</id>
    <published>2021-02-18T03:30:40.000Z</published>
    <updated>2023-10-09T08:40:48.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文总结一些图像算法，有些可能介绍不太详细（原理比较简单），有些可能会在另外的文章中介绍。</p><h1 id="2-详述"><a href="#2-详述" class="headerlink" title="2. 详述"></a>2. 详述</h1><h2 id="2-1-锐化"><a href="#2-1-锐化" class="headerlink" title="2.1. 锐化"></a>2.1. 锐化</h2><p>TODO</p><h2 id="2-2-滤波"><a href="#2-2-滤波" class="headerlink" title="2.2. 滤波"></a>2.2. 滤波</h2><h3 id="2-2-1-Box-Filter"><a href="#2-2-1-Box-Filter" class="headerlink" title="2.2.1. Box Filter"></a>2.2.1. Box Filter</h3><p>盒式滤波器（Box Filter）的主要功能是：在给定的滑动窗口大小下，对每个窗口内的像素值进行快速相加求和。</p><script type="math/tex; mode=display">\frac{1}{9} \begin{bmatrix} 1 & 1 & 1 \\ 1 & 1 & 1 \\ 1 & 1 & 1 \end{bmatrix}</script><h3 id="2-2-2-Gaussian-Filter"><a href="#2-2-2-Gaussian-Filter" class="headerlink" title="2.2.2. Gaussian Filter"></a>2.2.2. Gaussian Filter</h3><p>高斯滤波器（Gaussian Filter）是一种线性滤波器，能够有效的抑制噪声，平滑图像。其作用原理和均值滤波器类似，都是取滤波器窗口内的像素的均值作为输出。其窗口模板的系数和均值滤波器不同，均值滤波器的模板系数都是相同的为1；而高斯滤波器的模板系数，则随着距离模板中心的增大而系数减小。所以，高斯滤波器相比于均值滤波器对图像个模糊程度较小。</p><script type="math/tex; mode=display">\frac{1}{16}\begin{bmatrix} 1 & 2 & 1 \\ 2 & 4 & 2 \\ 1 & 2 & 1 \end{bmatrix}</script><script type="math/tex; mode=display">\frac{1}{256}\begin{bmatrix}1 & 4 & 6 & 4 & 1 \\ 4 & 16 & 24 & 16 & 4 \\ 6 & 24 & 36 & 24 & 6 \\ 4 & 16 & 24 & 16 & 4 \\ 1 & 4 & 6 & 4 & 1\end{bmatrix}</script><h3 id="2-2-3-Sobel-Filter"><a href="#2-2-3-Sobel-Filter" class="headerlink" title="2.2.3. Sobel Filter"></a>2.2.3. Sobel Filter</h3><p>索贝尔滤波器（Sobel Filter）常用来提取灰度图像的水平边缘（水平特征）和竖直边缘（竖直特征）。</p><script type="math/tex; mode=display">\begin{bmatrix} -1 & 0 & 1 \\ -2 & 0 & -2 \\ -1 & 0 & 1 \end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix} -1 & -2 & -1 \\ 0 & 0 & 0 \\ 1 & 2 & 1 \end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix}-1 & -2 & 0 & 2 & 1 \\ -4 & -8 & 0 & 8 & 4 \\ -6 & -12 & 0 & 12 & 6 \\ -4 & -8 & 0 & 8 & 4 \\ -1 & -2 & 0 & 2 & 1\end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix}-1 & -4 & -6 & -4 & -1 \\ -2 & -8 & 12 & -8 & -2 \\ 0 & 0 & 0 & 0 & 0 \\ 2 & 8 & 12 & 8 & 2 \\ 1 & 4 & 6 & 4 & 1\end{bmatrix}</script><h3 id="2-2-4-Scharr-Filter"><a href="#2-2-4-Scharr-Filter" class="headerlink" title="2.2.4. Scharr Filter"></a>2.2.4. Scharr Filter</h3><p>Scharr滤波器与Sobel滤波器原理相同，但在当滤波核大小为3时，运算与一样快，结果却更加精确。</p><script type="math/tex; mode=display">\begin{bmatrix} 3 & 0 & -3 \\ 10 & 0 & -10 \\ 3 & 0 & -3 \end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix} 3 & 10 & 3 \\ 0 & 0 & 0 \\ -3 & -10 & -3 \end{bmatrix}</script><h3 id="2-2-5-Dilation-Filter、Erosion-Filter"><a href="#2-2-5-Dilation-Filter、Erosion-Filter" class="headerlink" title="2.2.5. Dilation Filter、Erosion Filter"></a>2.2.5. Dilation Filter、Erosion Filter</h3><ul><li>膨胀滤波器（Dilation Filter）形态学运算之一，可以看作是最大值滤波，它将输入的二值图像（或灰度图像）中每一个元素的值替换为以该点为中心的邻域窗口内所有元素值的最大值。原理是将滤波核最大的值作为滤波后的元素，作用是将白色区域放大。</li><li>腐蚀滤波器（Erosion Filter）形态学运算之一，可以看作是最小值滤波，它将输入的二值图像（或灰度图像）中每一个元素的值替换为以该点为中心的邻域窗口内所有元素值的最小值。原理是将滤波核最小的值作为滤波后的元素，作用是将黑色区域放大。</li></ul><h3 id="2-2-6-Bilateral-Filter"><a href="#2-2-6-Bilateral-Filter" class="headerlink" title="2.2.6. Bilateral Filter"></a>2.2.6. Bilateral Filter</h3><p>双边滤波</p><p>TODO</p><h2 id="2-3-角点检测算法"><a href="#2-3-角点检测算法" class="headerlink" title="2.3. 角点检测算法"></a>2.3. 角点检测算法</h2><h3 id="2-3-1-Harris-角点检测器"><a href="#2-3-1-Harris-角点检测器" class="headerlink" title="2.3.1. Harris 角点检测器"></a>2.3.1. Harris 角点检测器</h3><p>TODO</p><h3 id="2-3-2-Shi-Tomasi-角点检测器"><a href="#2-3-2-Shi-Tomasi-角点检测器" class="headerlink" title="2.3.2. Shi-Tomasi 角点检测器"></a>2.3.2. Shi-Tomasi 角点检测器</h3><p>TODO</p><h3 id="2-3-3-FAST角点检测算法"><a href="#2-3-3-FAST角点检测算法" class="headerlink" title="2.3.3. FAST角点检测算法"></a>2.3.3. FAST角点检测算法</h3><p>TODO</p><h2 id="2-4-边缘检测算法"><a href="#2-4-边缘检测算法" class="headerlink" title="2.4. 边缘检测算法"></a>2.4. 边缘检测算法</h2><h3 id="2-4-1-Canny"><a href="#2-4-1-Canny" class="headerlink" title="2.4.1. Canny"></a>2.4.1. Canny</h3><p>TODO</p><h2 id="2-5-模糊（blur）算法"><a href="#2-5-模糊（blur）算法" class="headerlink" title="2.5. 模糊（blur）算法"></a>2.5. 模糊（blur）算法</h2><h3 id="2-5-1-高斯模糊（Gaussian-Blur）"><a href="#2-5-1-高斯模糊（Gaussian-Blur）" class="headerlink" title="2.5.1. 高斯模糊（Gaussian Blur）"></a>2.5.1. 高斯模糊（Gaussian Blur）</h3><p>参考该<a href="https://cloud.tencent.com/developer/article/1343067">文章</a></p><p>该方法本质上是一种数据平滑（data smoothing）技术，使用正态分布（高斯函数）计算模糊模板，并使用该模板与原图像做卷积运算，达到模糊图像的目的。</p><p>N维空间正态分布方程为：</p><script type="math/tex; mode=display">G(r)=\frac{1}{\sqrt{2\pi\sigma^{2}}^{N}}e^{-r^{2}/(2\sigma^{2})}</script><p>其中数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.292ex" height="1ex" role="img" focusable="false" viewBox="0 -431 571 442"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g></g></g></svg></mjx-container>是正态分布的标准差，该值越大，图像越模糊（平滑）。r为模糊半径，是指模板元素到模板中心的距离。如果二维模板大小为<code>m*n</code>，则模板上的元素(x,y)对应的高斯计算公式为：</p><script type="math/tex; mode=display">G(x,y)=\frac{1}{\sqrt{2\pi\sigma^{2}}^{N}}e^{-\frac{(x-m/2)^{2}+(y-n/2))^{2}}{2\sigma^{2}}}</script><p>在二维空间中，这个公式生成的曲面的等高线是从中心开始呈正态分布的同心圆，如图所示。</p><p>添加一张二维高斯曲面图片。</p><p>分布不为零的像素组成的卷积矩阵与原始图像做变换。每个像素的值都是周围相邻像素值的加权平均。原始像素的值有最大的高斯分布值，所以有最大的权重，相邻像素随着距离原始像素越来越远，其权重也越来越小。这样进行模糊处理比其它的均衡模糊滤波器更高地保留了边缘效果。</p><p>理论上来讲，图像中每点的分布都不为零，这也就是说每个像素的计算都需要包含整幅图像。在实际应用中，在计算高斯函数的离散近似时，在大概<code>3σ</code>距离之外的像素都可以看作不起作用，这些像素的计算也就可以忽略。通常，图像处理程序只需要计算数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.068ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 4008 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path></g><g data-mml-node="mi" transform="translate(889,0)"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="mo" transform="translate(1682.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(2682.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="msup" transform="translate(3182.4,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" transform="translate(422,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></g></svg></mjx-container>大小的矩阵就可以保证相关像素影响。注意：（1）矩阵中的值需要进行归一化（2）矩阵是中心对称的。</p><h3 id="2-5-2-分离高斯滤波"><a href="#2-5-2-分离高斯滤波" class="headerlink" title="2.5.2. 分离高斯滤波"></a>2.5.2. 分离高斯滤波</h3><p>高斯函数的可分离性是指使用二维矩阵变换得到的效果也可以通过在水平方向进行一维高斯矩阵变换加上竖直方向的一维高斯矩阵变换得到。从计算的角度来看，这是一项有用的特性，因为这样只需要数学公式: $O(m<em>M</em>N)+O(n<em>M</em>N)<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="46.506ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 20555.8 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">次</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">计</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">算</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">而</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">二</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">维</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">不</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">可</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">分</text></g><g data-mml-node="mi" transform="translate(10000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(11000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">矩</text></g><g data-mml-node="mi" transform="translate(12000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">阵</text></g><g data-mml-node="mi" transform="translate(13000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">则</text></g><g data-mml-node="mi" transform="translate(14000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">需</text></g><g data-mml-node="mi" transform="translate(15000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">要</text></g><g data-mml-node="mi" transform="translate(16000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mi" transform="translate(17000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">学</text></g><g data-mml-node="mi" transform="translate(18000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">公</text></g><g data-mml-node="mi" transform="translate(19000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">式</text></g><g data-mml-node="mo" transform="translate(20277.8,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g></g></g></svg></mjx-container>O(m<em>n</em>M*N)$次计算。其中，m、n为高斯矩阵的维数，M、N为二维图像的维数。另外，两次一维的高斯卷积将消除二维高斯矩阵所产生的边缘。</p><h2 id="2-6-线性插值"><a href="#2-6-线性插值" class="headerlink" title="2.6. 线性插值"></a>2.6. 线性插值</h2><p>参考该<a href="https://zhuanlan.zhihu.com/p/110754637">文章</a></p><h2 id="2-7-积分图"><a href="#2-7-积分图" class="headerlink" title="2.7. 积分图"></a>2.7. 积分图</h2><p>参考该<a href="https://blog.csdn.net/tercel_zhang/article/details/79219924">文章</a></p><h2 id="2-8-色彩转换"><a href="#2-8-色彩转换" class="headerlink" title="2.8. 色彩转换"></a>2.8. 色彩转换</h2><p>TODO</p><h2 id="2-9-极值检测"><a href="#2-9-极值检测" class="headerlink" title="2.9. 极值检测"></a>2.9. 极值检测</h2><h3 id="2-9-1-尺度空间极值检测"><a href="#2-9-1-尺度空间极值检测" class="headerlink" title="2.9.1. 尺度空间极值检测"></a>2.9.1. 尺度空间极值检测</h3><p>（1）背景介绍</p><p>尺度空间（scale space）思想最早是由Iijima于1962年提出的，后经witkin和Koenderink等人的推广逐渐得到关注，在计算机视觉邻域使用广泛。Tony Lindeberg指出尺度规范化的LoG（Laplacion of Gaussian）算子具有真正的尺度不变性，Lowe（SIFT算法发明者）使用高斯差分金字塔近似LoG算子，在尺度空间检测稳定的关键点。</p><p>（2）原理简介</p><p>尺度空间理论的基本思想是：在图像信息处理模型中引入一个被视为尺度的参数，通过连续变化尺度参数获得多尺度下的尺度空间表示序列，对这些序列进行尺度空间主轮廓的提取，并以该主轮廓作为一种特征向量，实现边缘、角点检测和不同分辨率上的特征提取等。<br>尺度空间方法将传统的单尺度图像信息处理技术纳入尺度不断变化的动态分析框架中，更容易获取图像的本质特征。尺度空间中各尺度图像的模糊程度逐渐变大，能够模拟人在距离目标由近到远时目标在视网膜上的形成过程。</p><p>尺度空间满足视觉不变性，该不变性的视觉解释如下：当我们用眼睛观察物体时，一方面当物体所处背景的光照条件变化时，视网膜感知图像的亮度水平和对比度是不同的，因此要求尺度空间算子对图像的分析不受图像的灰度水平和对比度变化的影响，即满足灰度不变性和对比度不变性。另一方面，相对于某一固定坐标系，当观察者和物体之间的相对位置变化时，视网膜所感知的图像的位置、大小、角度和形状是不同的，因此要求尺度空间算子对图像的分析和图像的位置、大小、角度以及仿射变换无关，即满足平移不变性、尺度不变性、欧几里德不变性以及仿射不变性。</p><p>（3）具体过程</p><p>一个图像的尺度空间数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.008ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3981.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(681,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1070,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1642,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2086.7,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2576.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3021.3,0)"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="mo" transform="translate(3592.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>定义为一个变化尺度的高斯函数数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.245ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4086.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(786,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1175,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1747,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2191.7,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2681.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3126.3,0)"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="mo" transform="translate(3697.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>与原图像数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.309ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2788.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"></path></g><g data-mml-node="mo" transform="translate(504,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(893,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1465,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1909.7,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2399.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>的卷积，如式3.1所示：数学公式: $L(x,y,\sigma)=G(x,y,\sigma)<em>I(x,y)$，其中`</em>`表示卷积计算，数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.003ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3979.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(786,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1175,0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g><g data-mml-node="mo" transform="translate(1640,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2084.7,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2574.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3019.3,0)"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="mo" transform="translate(3590.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>如公式3.2所示：数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.67ex;" xmlns="http://www.w3.org/2000/svg" width="33.569ex" height="4.747ex" role="img" focusable="false" viewBox="0 -1360.3 14837.5 2098.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(786,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1175,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1747,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2191.7,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2681.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3126.3,0)"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="mo" transform="translate(3697.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(4364.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(5419.9,0)"><g data-mml-node="mn" transform="translate(1330.7,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="msup" transform="translate(220,-697) scale(0.707)"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g><g data-mml-node="msup" transform="translate(1070,0)"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="TeXAtom" transform="translate(604,289) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g><g data-mml-node="mo" transform="translate(0,124.4)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"></path></g><rect width="2077.6" height="42.4" x="853" y="882"></rect></g><g data-mml-node="TeXAtom" transform="translate(2963.6,729) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g></g></g><rect width="2774.9" height="60" x="120" y="220"></rect></g><g data-mml-node="msup" transform="translate(8434.8,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" transform="translate(499,480.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mfrac" transform="translate(778,0)"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(961,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1739,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2617,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(3117,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="msup" transform="translate(3617,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(422,363)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="mo" transform="translate(4589,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(5367,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(5756,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(6246,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(7024,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(7624,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(8124,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(8624,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="msup" transform="translate(9013,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(422,363)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g><g data-mml-node="mrow" transform="translate(3165.5,-515.3) scale(0.707)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="msup" transform="translate(500,0)"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(604,289)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g><rect width="7260.5" height="60" x="120" y="220"></rect></g></g></g></g></g></svg></mjx-container>，其中：数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.292ex" height="1ex" role="img" focusable="false" viewBox="0 -431 571 442"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g></g></g></svg></mjx-container>是尺度空间因子，值越小表示图像被平滑的越少，相应的尺度也就越小。大尺度对应于图像的概貌特征，小尺度对应于图像的细节特征。</p><p>尺度空间在实现时使用高斯金字塔表示，高斯金字塔的构建分为两部分：</p><ul><li>对图像做不同尺度的高斯模糊</li><li>对图像做降采样(隔点采样)</li></ul><p>图像的金字塔模型是指，将原始图像不断降阶采样，得到一系列大小不一的图像，由大到小，从下到上构成的塔状模型。原图像为金字塔的第一层，每次降采样所得到的新图像为金字塔的一层（每层一张图像），每个金字塔共n层。金字塔的层数根据图像的原始大小和塔顶图像的大小共同决定，其计算公式如公式3.3所示：</p><script type="math/tex; mode=display">n=log_{2}{min(M,N)}-t,t\in[0,log_{2}{min(M,N)}]</script><p>为了让尺度体现其连续性，高斯金字塔在简单降采样的基础上加上了高斯滤波。将图像金字塔每层的一张图像使用不同参数做高斯模糊，使得金字塔的每层含有多张高斯模糊图像，将金字塔每层多张图像合称为一组，金字塔每层只有一组图像，组数和金字塔层数相等，每组含有多张图像。另外，降采样时，高斯金字塔上一组图像的初始图像是由前一组图像的倒数第三张图像隔点采样得到的。</p><p><img src="/images/gaussian_pyramid.png" alt=""></p><p>2002年Mikolajczyk在详细的实验比较中发现尺度归一化的高斯拉普拉斯函数数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="7.685ex" height="1.937ex" role="img" focusable="false" viewBox="0 -833.9 3396.6 855.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="TeXAtom" transform="translate(604,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="msup" transform="translate(1229.8,0)"><g data-mml-node="mo"><path data-c="25BC" d="M84 556Q84 567 99 576H622Q637 567 637 556Q637 551 572 409T441 127T375 -14Q368 -19 360 -19H358Q349 -19 342 -7T296 92Q249 193 211 275Q84 550 84 556Z"></path></g><g data-mml-node="TeXAtom" transform="translate(755,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="mi" transform="translate(2610.6,0)"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></svg></mjx-container>的极大值和极小值同其它的特征提取函数（例如：梯度，Hessian或Harris角特征）比较，能够产生最稳定的图像特征。而Lindeberg早在1994年就发现高斯差分函数（Difference of Gaussian，DOG）与尺度归一化的高斯拉普拉斯函数非常近似。其中数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.34ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4128.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g><g data-mml-node="mo" transform="translate(828,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1217,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1789,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2233.7,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2723.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3168.3,0)"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="mo" transform="translate(3739.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>和数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="7.685ex" height="1.937ex" role="img" focusable="false" viewBox="0 -833.9 3396.6 855.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="TeXAtom" transform="translate(604,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="msup" transform="translate(1229.8,0)"><g data-mml-node="mo"><path data-c="25BC" d="M84 556Q84 567 99 576H622Q637 567 637 556Q637 551 572 409T441 127T375 -14Q368 -19 360 -19H358Q349 -19 342 -7T296 92Q249 193 211 275Q84 550 84 556Z"></path></g><g data-mml-node="TeXAtom" transform="translate(755,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="mi" transform="translate(2610.6,0)"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></svg></mjx-container>的关系如下推导：</p><script type="math/tex; mode=display">G(x,y,k\sigma)-G(x,y,\sigma)\approx(k-1)\sigma^{2}▼^{2}G</script><p>其中k-1为常数，不影响极值点位置的求取。</p><p>Lowe使用更高效的高斯差分算子代替拉普拉斯算子进行极值检测，如式3.4所示：</p><script type="math/tex; mode=display">D(x,y,\sigma)=(G(x,y,k\sigma)-G(x,y,\sigma))*I(x,y)=L(x,y,k\sigma)-L(x,y,\sigma)</script><p><img src="/images/gaussian_difference_pyramid.png" alt=""></p><p>接下来可以进行空间极值点检测，首先寻找关键点。关键点是由DOG空间的局部极值点组成的，关键点的初步探查是通过同一组内各DoG相邻两层图像之间比较完成的。为了寻找DoG函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度域的相邻点大或者小。</p><p>在上述尺度空间内，O（组数）、S（组内层数）和数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.292ex" height="1ex" role="img" focusable="false" viewBox="0 -431 571 442"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g></g></g></svg></mjx-container>（尺度空间坐标）的关系如式3.5所示：</p><script type="math/tex; mode=display">\sigma(o,s)=\sigma_{0}2^{o+s/S},o\in[0,...,O-1],s\in[0,...,S+2]</script><p>其中：数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.28ex" height="1.35ex" role="img" focusable="false" viewBox="0 -431 1007.6 596.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="TeXAtom" transform="translate(604,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></g></svg></mjx-container>是基准层尺度，o为组的索引，s为组内层数的索引。一般建立高斯金字塔时，先将图像的尺度扩大一倍来生成第-1组，做数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.471ex;" xmlns="http://www.w3.org/2000/svg" width="9.433ex" height="1.977ex" role="img" focusable="false" viewBox="0 -666 4169.2 874"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="TeXAtom" transform="translate(604,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1835.5,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2891.2,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(778,0)"></path></g></g></g></svg></mjx-container>的高斯模糊。如果输入图像的尺寸用双线性插值扩大一倍，那么数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.471ex;" xmlns="http://www.w3.org/2000/svg" width="7.672ex" height="1.977ex" role="img" focusable="false" viewBox="0 -666 3391.2 874"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="TeXAtom" transform="translate(604,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1835.5,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2891.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>。式3.4中k为组内总层数的倒数，如式3.6所示：k=2^(1/S)。构造高斯金字塔，组内每层的尺度坐标按公式3.7计算：</p><p>数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.628ex;" xmlns="http://www.w3.org/2000/svg" width="28.537ex" height="2.851ex" role="img" focusable="false" viewBox="0 -982.5 12613.2 1260"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="mo" transform="translate(571,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(960,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mo" transform="translate(1429,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2095.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msqrt" transform="translate(3151.6,0)"><g transform="translate(1020,0)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="TeXAtom" transform="translate(554,289) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g><g data-mml-node="msub" transform="translate(1324.6,0)"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="TeXAtom" transform="translate(604,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g><g data-mml-node="msup" transform="translate(2332.2,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" transform="translate(422,289) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="mo" transform="translate(3380,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mo" transform="translate(4380.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(4769.2,0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="TeXAtom" transform="translate(554,289) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mo" transform="translate(469,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1247,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="msub" transform="translate(6608.5,0)"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="TeXAtom" transform="translate(604,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g><g data-mml-node="msup" transform="translate(7616.1,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" transform="translate(422,289) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g><g data-mml-node="mo" transform="translate(0,72.5)"><path data-c="221A" d="M263 249Q264 249 315 130T417 -108T470 -228L725 302Q981 837 982 839Q989 850 1001 850Q1008 850 1013 844T1020 832V826L741 243Q645 43 540 -176Q479 -303 469 -324T453 -348Q449 -350 436 -350L424 -349L315 -96Q206 156 205 156L171 130Q138 104 137 104L111 130L263 249Z"></path></g><rect width="8441.6" height="60" x="1020" y="862.5"></rect></g></g></g></svg></mjx-container>，其中：数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="14.802ex" height="2.034ex" role="img" focusable="false" viewBox="0 -705 6542.3 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="TeXAtom" transform="translate(604,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1285.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2341.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(3619.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(4063.8,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(4986.6,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(6042.3,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></svg></mjx-container>，不同组相同层的组内尺度坐标相同。组内下一层由前一层按数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex;" xmlns="http://www.w3.org/2000/svg" width="2.23ex" height="1.33ex" role="img" focusable="false" viewBox="0 -431 985.6 588.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="TeXAtom" transform="translate(604,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></g></g></svg></mjx-container>进行高斯模糊得到。计算不同组内某一层图像的尺度时，使用公式3.8进行计算：数学公式: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="30.869ex" height="2.587ex" role="img" focusable="false" viewBox="0 -893.3 13644 1143.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="mi" transform="translate(604,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g></g><g data-mml-node="mi" transform="translate(996.9,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(1429.9,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(2068.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(3124.5,0)"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="TeXAtom" transform="translate(604,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g><g data-mml-node="msup" transform="translate(4132.1,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(469,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(969,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g></g></g><g data-mml-node="mo" transform="translate(5856.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(6301,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mo" transform="translate(7047.8,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="mo" transform="translate(7992.5,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(8270.5,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(8770.5,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(9215.2,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(10553.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(10998.5,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(11865.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(12866,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(13366,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>，该组内尺度在方向分配和特征描述时确定采样窗口的大小。</p><p>由以上得出，式3.4可记为式3.9：</p><script type="math/tex; mode=display">D(x,y,\sigma)=(G(x,y,\sigma(s+1))-G(x,y,\sigma(s)))*I(x,y)=L(x,y,\sigma(s+1))-L(x,y,\sigma(s))</script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;本文总结一些图像算法，有些可能介绍不太详细（原理比较简单），有些可能会在另外的文章中介绍。&lt;/p&gt;
&lt;h1 id=&quot;2-</summary>
      
    
    
    
    
    <category term="图像" scheme="http://cakgod.github.io/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>静态链接</title>
    <link href="http://cakgod.github.io/2020/01/02/static-link/"/>
    <id>http://cakgod.github.io/2020/01/02/static-link/</id>
    <published>2020-01-02T01:56:32.000Z</published>
    <updated>2023-10-08T03:52:22.288Z</updated>
    
    <content type="html"><![CDATA[<p>TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TODO&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="编译" scheme="http://cakgod.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>hexo_use</title>
    <link href="http://cakgod.github.io/2019/08/04/hexo-use/"/>
    <id>http://cakgod.github.io/2019/08/04/hexo-use/</id>
    <published>2019-08-04T06:56:25.000Z</published>
    <updated>2023-10-09T08:05:18.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文介绍了在各种hexo主题上支持markdown公式的方法。</p><h1 id="2-参考文章"><a href="#2-参考文章" class="headerlink" title="2. 参考文章"></a>2. 参考文章</h1><p>感谢大神！<a href="https://myblackboxrecorder.com/use-math-in-hexo/">在任意的hexo主题支持数学公式</a></p><h1 id="3-详述"><a href="#3-详述" class="headerlink" title="3. 详述"></a>3. 详述</h1><h2 id="3-1-安装MathJax"><a href="#3-1-安装MathJax" class="headerlink" title="3.1. 安装MathJax"></a>3.1. 安装MathJax</h2><p>MathJax就是用来渲染数学公式的js引擎。在这之前需要卸载自带的hexo-math以避免冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-math --save</span><br><span class="line">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure><h2 id="3-2-更新MathJax的CDN链接"><a href="#3-2-更新MathJax的CDN链接" class="headerlink" title="3.2. 更新MathJax的CDN链接"></a>3.2. 更新MathJax的CDN链接</h2><p>打开<code>node_modules/hexo-renderer-mathjax/mathjax.html</code>，将最后一行CDN地址修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-3-更换默认渲染引擎"><a href="#3-3-更换默认渲染引擎" class="headerlink" title="3.3. 更换默认渲染引擎"></a>3.3. 更换默认渲染引擎</h2><p>Hexo默认的渲染引擎hexo-renderer-marked对MathJax的支持很不好，修改为kramed引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><h2 id="3-4-更改转移规则"><a href="#3-4-更改转移规则" class="headerlink" title="3.4. 更改转移规则"></a>3.4. 更改转移规则</h2><p>因为hexo默认的转义规则会将一些字符进行转义，比如<code>_</code>转为<code>&lt;em&gt;</code>，所以需要对默认的规则进行修改。</p><p>打开<code>node_modules/kramed/lib/rules/inline.js</code>，把：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([`*\[\]()# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure><p>把：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure><h2 id="3-5-使用hexo-filter-mathjax"><a href="#3-5-使用hexo-filter-mathjax" class="headerlink" title="3.5. 使用hexo-filter-mathjax"></a>3.5. 使用hexo-filter-mathjax</h2><p>安装<a href="https://github.com/next-theme/hexo-filter-mathjax">hexo-filter-mathjax</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-mathjax --save</span><br></pre></td></tr></table></figure><p>对于需要开启公式支持的博文，在开头处添加<code>mathjax: true</code>这行即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;本文介绍了在各种hexo主题上支持markdown公式的方法。&lt;/p&gt;
&lt;h1 id=&quot;2-参考文章&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="问题" scheme="http://cakgod.github.io/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>汇编相关知识</title>
    <link href="http://cakgod.github.io/2018/03/12/ass-using/"/>
    <id>http://cakgod.github.io/2018/03/12/ass-using/</id>
    <published>2018-03-12T08:14:39.000Z</published>
    <updated>2023-10-16T01:35:38.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文总结了一些汇编相关的基础知识。</p><h1 id="2-详述"><a href="#2-详述" class="headerlink" title="2. 详述"></a>2. 详述</h1><h2 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1. 基础知识"></a>2.1. 基础知识</h2><ul><li>帧指针（FP，frame pointer）寄存器，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</li><li>栈指针（SP，stack pointer）寄存器，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</li><li>基指针（BP，base pointer）寄存器，其内存中存放着一个指针，该指针指向当前栈帧的底部。</li><li>函数栈帧：SP和BP之间的内存空间为当前栈帧，BP标识了当前栈帧的底部，SP标识了当前栈帧的顶部。</li><li>指令指针（IP，instruction pointer）寄存器， 其内存放着一个指针，该指针永远指向下一条待执行的指令地址。</li></ul><h2 id="2-2-函数调用的步骤"><a href="#2-2-函数调用的步骤" class="headerlink" title="2.2. 函数调用的步骤"></a>2.2. 函数调用的步骤</h2><ul><li>参数入栈：将参数从右向左依次压入系统栈中</li><li>返回地址入栈：将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行</li><li>代码区跳转：处理器从当前代码区跳转到被调用函数的入口处</li><li>栈帧调整：具体包括：（1）保存当前栈帧状态值，以备后面恢复本栈帧时使用（EBP入栈）。（2）将当前栈帧切换到新栈帧（将ESP值装入EBP，更新栈帧底部）。（3）给新栈帧分配空间（把ESP减去所需空间的大小，抬高栈顶）。</li></ul><p>以如下的C语言程序为例，看一下汇编语言中的过程。C语言代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int func(int a, int b, int c)</span><br><span class="line">&#123;</span><br><span class="line">        a = 100;</span><br><span class="line">        b = 200;</span><br><span class="line">        c = 300;</span><br><span class="line">        printf(&quot;%d\n&quot;, a);</span><br><span class="line"></span><br><span class="line">        return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">        func(1, 2, 3);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;func&gt;:</span><br><span class="line">   0:   55                      push   %rbp             ;将BP压栈。</span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp        ;用SP的值覆盖BP。</span><br><span class="line">   4:   48 83 ec 10             sub    $0x10,%rsp       ;SP向低地址偏移，开栈，这里开栈16B。</span><br><span class="line">   8:   89 7d fc                mov    %edi,-0x4(%rbp)  ;根据BP向负方向偏移，获取三个参数存储到寄存器。</span><br><span class="line">   b:   89 75 f8                mov    %esi,-0x8(%rbp)</span><br><span class="line">   e:   89 55 f4                mov    %edx,-0xc(%rbp)</span><br><span class="line">  11:   c7 45 fc 64 00 00 00    movl   $0x64,-0x4(%rbp)</span><br><span class="line">  18:   c7 45 f8 c8 00 00 00    movl   $0xc8,-0x8(%rbp)</span><br><span class="line">  1f:   c7 45 f4 2c 01 00 00    movl   $0x12c,-0xc(%rbp)</span><br><span class="line">  26:   8b 45 fc                mov    -0x4(%rbp),%eax  </span><br><span class="line">  29:   89 c6                   mov    %eax,%esi        ;根据程序，将第一个参数移到返回值寄存器。</span><br><span class="line">  2b:   bf 00 00 00 00          mov    $0x0,%edi</span><br><span class="line">  30:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  35:   e8 00 00 00 00          callq  3a &lt;func+0x3a&gt;</span><br><span class="line">  3a:   8b 45 fc                mov    -0x4(%rbp),%eax</span><br><span class="line">  3d:   c9                      leaveq </span><br><span class="line">  3e:   c3                      retq   </span><br><span class="line"></span><br><span class="line">000000000000003f &lt;main&gt;:</span><br><span class="line">  3f:   55                      push   %rbp             ;将BP压栈</span><br><span class="line">  40:   48 89 e5                mov    %rsp,%rbp        ;用SP的值覆盖BP</span><br><span class="line">  43:   48 83 ec 10             sub    $0x10,%rsp       ;SP向低地址偏移，开栈。这里开栈16B。</span><br><span class="line">  47:   89 7d fc                mov    %edi,-0x4(%rbp)  ;</span><br><span class="line">  4a:   48 89 75 f0             mov    %rsi,-0x10(%rbp)</span><br><span class="line">  4e:   ba 03 00 00 00          mov    $0x3,%edx        ;通过寄存器传参，存储三个参数到edx、esi、edi三个寄存器中。</span><br><span class="line">  53:   be 02 00 00 00          mov    $0x2,%esi</span><br><span class="line">  58:   bf 01 00 00 00          mov    $0x1,%edi</span><br><span class="line">  5d:   e8 00 00 00 00          callq  62 &lt;main+0x23&gt;   ;调用func函数。</span><br><span class="line">  62:   b8 00 00 00 00          mov    $0x0,%eax        ;将0存储到eax寄存器中。</span><br><span class="line">  67:   c9                      leaveq </span><br><span class="line">  68:   c3                      retq</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;本文总结了一些汇编相关的基础知识。&lt;/p&gt;
&lt;h1 id=&quot;2-详述&quot;&gt;&lt;a href=&quot;#2-详述&quot; class=&quot;h</summary>
      
    
    
    
    
    <category term="汇编" scheme="http://cakgod.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>hexo中添加电子宠物</title>
    <link href="http://cakgod.github.io/2017/10/16/hexo-live/"/>
    <id>http://cakgod.github.io/2017/10/16/hexo-live/</id>
    <published>2017-10-16T03:22:40.000Z</published>
    <updated>2023-10-16T03:29:11.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本文总结了一下如何在hexo中添加一个电子宠物的简单步骤。</p><h1 id="2-详述"><a href="#2-详述" class="headerlink" title="2. 详述"></a>2. 详述</h1><h2 id="2-1-查看版本"><a href="#2-1-查看版本" class="headerlink" title="2.1. 查看版本"></a>2.1. 查看版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h2 id="2-2-安装live2d"><a href="#2-2-安装live2d" class="headerlink" title="2.2. 安装live2d"></a>2.2. 安装live2d</h2><p>npm install —save hexo-helper-live2d</p><h2 id="2-3-选择电子宠物样式"><a href="#2-3-选择电子宠物样式" class="headerlink" title="2.3. 选择电子宠物样式"></a>2.3. 选择电子宠物样式</h2><p>可以去网上搜索live2d的模型代号和样式，自己挑一个。我选的大白猫（live2d-widget-model-tororo）。</p><h2 id="2-4-修改配置"><a href="#2-4-修改配置" class="headerlink" title="2.4. 修改配置"></a>2.4. 修改配置</h2><p>在站点根目录下的<code>_config.yml</code>中添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Live2D</span><br><span class="line">## https://github.com/EYHN/hexo-helper-live2d</span><br><span class="line">## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  #enable: false</span><br><span class="line">  scriptFrom: local # 默认</span><br><span class="line">  pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径)</span><br><span class="line">  pluginJsPath: lib/ # 脚本文件相对与插件根目录路径</span><br><span class="line">  pluginModelPath: assets/ # 模型文件相对与插件根目录路径</span><br><span class="line">  # scriptFrom: jsdelivr # jsdelivr CDN</span><br><span class="line">  # scriptFrom: unpkg # unpkg CDN</span><br><span class="line">  # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span><br><span class="line">  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br><span class="line">  debug: false # 调试, 是否在控制台输出日志</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-hibiki</span><br><span class="line">    # use: live2d-widget-model-wanko # npm-module package name</span><br><span class="line">    # use: wanko # 博客根目录/live2d_models/ 下的目录名</span><br><span class="line">    # use: ./wives/wanko # 相对于博客根目录的路径</span><br><span class="line">    # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span><br><span class="line">  display:</span><br><span class="line">    position: left</span><br><span class="line">    width: 145</span><br><span class="line">    height: 315</span><br><span class="line">  mobile:</span><br><span class="line">    show: true # 是否在移动设备上显示</span><br><span class="line">    scale: 0.5 # 移动设备上的缩放       </span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7</span><br><span class="line">    opacityOnHover: 0.8</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;本文总结了一下如何在hexo中添加一个电子宠物的简单步骤。&lt;/p&gt;
&lt;h1 id=&quot;2-详述&quot;&gt;&lt;a href=&quot;#2-</summary>
      
    
    
    
    
    <category term="问题" scheme="http://cakgod.github.io/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>vim常用命令</title>
    <link href="http://cakgod.github.io/2017/10/12/vim-using/"/>
    <id>http://cakgod.github.io/2017/10/12/vim-using/</id>
    <published>2017-10-12T01:13:20.000Z</published>
    <updated>2023-10-12T01:43:46.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在说vim之前，先说下什么是vi。vi是visual interface的简称，是Linux中最经典的文本编辑器。vi的核心设计思想是：让程序员的手始终保持在键盘的核心区域就能够完成所有的编辑操作。而vim又是从vi发展出来的一个文本编辑器，即vi improved，它在代码补全、编译及错误跳转等方便编程的功能上特别丰富，在程序员中被广泛使用。</p><h1 id="2-vim的工作模式"><a href="#2-vim的工作模式" class="headerlink" title="2. vim的工作模式"></a>2. vim的工作模式</h1><p>vim有三种主要的工作模式</p><ul><li>命令模式（Command mode）：用户启动vim时，首先进入的便是命令模式。命令模式可认为是vim的入口，此模式下敲击键盘的字符都会被当做命令，而非在文本中插入字符。</li><li>插入模式（Insert mode）：此模式下可以正常地编辑文字，与平时使用习惯差别不大。</li><li>底行模式（Last line mode）：此模式下可以执行保存、退出以及其他的一些功能。按下<code>esc+：</code>即可进入底行模式。输入wq为保存退出，输入q!为不保存退出。</li></ul><p>此外，还有其他一些模式，如可视模式（Visual）、替换模式（Replace）等。</p><h1 id="3-常用命令介绍"><a href="#3-常用命令介绍" class="headerlink" title="3. 常用命令介绍"></a>3. 常用命令介绍</h1><h2 id="3-1-移动"><a href="#3-1-移动" class="headerlink" title="3.1 移动"></a>3.1 移动</h2><p>方位移动</p><ul><li>h：光标左移一格</li><li>j：光标下移一格</li><li>k：光标上移一格</li><li>l：光标右移一格</li></ul><p>使用方向键也是允许的。</p><p>行内移动</p><ul><li>0：光标移至行首</li><li>$：光标移至行尾</li><li>^：光标移到当前行的第一个非空字符</li><li><code>g_</code>：光标移到当前行的最后一个非空字符</li><li>b：光标到上一个字的开头</li><li>w：光标到下一个字的开头</li><li>e：光标移到下一个字的结尾</li><li>ge：光标移到上一个字的结尾</li><li>fa：移到下一个a出现的位置（F与之相反）</li><li>ta：移到下一个a出现位置的前一个位置（T与之相反）</li></ul><p>行间移动</p><ul><li>G：光标移至文末</li><li>gg：光标移至开头</li><li>Ngg或NG：光标移至N行开头</li></ul><p>语义移动</p><ul><li>(：光标移至上一句首</li><li>)：光标移至下一句首</li><li>{：光标移至段首</li><li>}：光标移至段尾</li></ul><p>屏幕移动</p><ul><li>H：将光标移到屏幕的最顶行</li><li>M：将光标移到屏幕中间</li><li>L：将光标移到屏幕最底行</li><li>Ctrl+b：向上翻页</li><li>Ctrl+f：向下翻页</li></ul><h2 id="3-2-选择"><a href="#3-2-选择" class="headerlink" title="3.2 选择"></a>3.2 选择</h2><p>此功能需进入可视模式，方法为按下键盘上的v键。然后搭配上面移动的相关命令即可实现文本的选择。常用的有ggvG可实现全选，v$可实现选中某行，Ctrl+v可进入可视块模式，允许垂直方向选择文本。</p><p>可视模式更详细的用法可参考：</p><p><a href="https://blog.csdn.net/ii1245712564/article/details/46960387">https://blog.csdn.net/ii1245712564/article/details/46960387</a></p><h2 id="3-3-复制"><a href="#3-3-复制" class="headerlink" title="3.3 复制"></a>3.3 复制</h2><ul><li>y：复制</li><li>yy：复制一行</li><li>Nyy：复制从光标处起的N行内容</li><li>yw：复制光标处至词尾的内容</li><li>yaw：复制光标所在单词</li><li>ya”：yank around”,复制整个字符串包括引号</li><li>yi”：yank inside”,复制引号之间的内容，不包括引号（类似还有yi（、yi[等）</li></ul><h2 id="3-4-粘贴"><a href="#3-4-粘贴" class="headerlink" title="3.4 粘贴"></a>3.4 粘贴</h2><ul><li>p（小写）：在光标后粘贴复制或剪切的内容</li><li>P（大写）：在光标前粘贴复制或剪切的内容</li></ul><h2 id="3-5-删除（剪切）"><a href="#3-5-删除（剪切）" class="headerlink" title="3.5 删除（剪切）"></a>3.5 删除（剪切）</h2><ul><li>x：删除光标所在字符（cut）</li><li>d：删除（可与移动命令搭配使用，自行探索）</li><li>dd：删除光标所在行</li><li>D：从光标处删至行尾（与d0等同）</li><li>dw：删除光标至词尾的内容</li><li>daw：删除光标所在单词</li></ul><h2 id="3-6-撤销"><a href="#3-6-撤销" class="headerlink" title="3.6 撤销"></a>3.6 撤销</h2><ul><li>u：撤销上次命令（undo）</li></ul><h2 id="3-7-恢复"><a href="#3-7-恢复" class="headerlink" title="3.7 恢复"></a>3.7 恢复</h2><ul><li>Ctrl+r：恢复撤销的命令（redo）</li></ul><h2 id="3-8-查找"><a href="#3-8-查找" class="headerlink" title="3.8 查找"></a>3.8 查找</h2><ul><li>/str：查找字符串str第一次出现的位置</li><li>n：当查找到指定内容后，继续查找下一个</li><li>N：查找上一个</li><li>*：向后查找当前光标所在单词</li><li>#：向前查找当前光标所在单词</li><li>fa：向后查找第一个a出现的位置</li><li>;：重复上一次f查找命令</li></ul><h2 id="3-9-替换（修改）"><a href="#3-9-替换（修改）" class="headerlink" title="3.9 替换（修改）"></a>3.9 替换（修改）</h2><ul><li>r：替换光标所在字符</li><li>R：此时将进入替换模式，每输入一个字符就会替换光标所在字符，并使光标后移一格，以便继续替换。</li><li>s：删除当前字符并插入</li><li>cw： 替换从光标所在位置到当前单词结尾的字符</li><li>caw：删除光标所在单词并插入</li><li>ci”：删除“…”之间的内容并插入（类似还有ci（、ci[等）</li><li>.：重复上一次修改命令</li><li>“.：跳转到上次修改所在行</li><li>`.：跳转到上次修改所在位置</li></ul><h2 id="3-10-缩进"><a href="#3-10-缩进" class="headerlink" title="3.10 缩进"></a>3.10 缩进</h2><ul><li>>>：增加缩进</li><li>&lt;&lt;：减少缩进</li><li>gg=G：自动全文缩进</li></ul><h2 id="3-11-标记"><a href="#3-11-标记" class="headerlink" title="3.11 标记"></a>3.11 标记</h2><ul><li>mx：添加标记x,x可以是a～z或A~Z之间的任意字母</li><li>‘x：定位到标记x所在行行首</li><li>`x：定位到标记的确切位置</li></ul><h2 id="3-12-查看历史"><a href="#3-12-查看历史" class="headerlink" title="3.12 查看历史"></a>3.12 查看历史</h2><ul><li><p>q:：查看历史命令</p></li><li><p>q/：查看搜索历史</p></li></ul><p>补充：查看或编辑某条记录后按Enter可执行该条记录。按Ctrl+c可退出历史编辑</p><h2 id="3-13-进入插入模式"><a href="#3-13-进入插入模式" class="headerlink" title="3.13 进入插入模式"></a>3.13 进入插入模式</h2><ul><li>i：在当前字符前插入文本</li><li>I：在行首插入文本</li><li>a：在当前字符后插入文本</li><li>A：在行尾插入文本</li><li>o：在当前行后面插入空行</li><li>O：在当前行前面插入空行</li></ul><h2 id="3-14-进入底行模式"><a href="#3-14-进入底行模式" class="headerlink" title="3.14 进入底行模式"></a>3.14 进入底行模式</h2><p>esc+:：进入底行模式</p><p>常用</p><ul><li>w filename：保存或重命名当前文件</li><li>wq：保存退出</li><li>saveas <path/to/file>：另存为指定路径下文件</li><li>e <path/to/file>：打开路径下的文件</li><li>q：在未做修改的情况下退出</li><li>q!：不保存退出</li></ul><p>行相关</p><ul><li>N：跳至第N行</li><li>set nu：显示行号（nu即number）</li><li>set nonu：隐藏行号（nonu即no number）</li><li>J：拼接当前行和下一行</li><li>set ts=N：设置Tab键跳过的空格数为N（ts即tabstop）</li></ul><p>基本排版</p><ul><li>ce（nter）：本行文字居中</li><li>le（ft）：本行文字左对齐</li><li>ri（ght）：本行文字右对齐</li></ul><p>标签页</p><ul><li>tabnew filename：新建标签页</li><li>tabn：跳到下个标签页</li><li>tabp：跳到上个标签页</li><li>tabc：关闭当前标签页</li></ul><p>分屏</p><ul><li>sp：左右分屏</li><li>vsp：上下分屏</li></ul><p>补充：可使用Ctrl+w+w实现不同窗口的转动切换，方向为逆时针旋转；也可使用Ctrl+w搭配h、i、j、k或方向键实现窗口切换。</p><h2 id="3-15-其他tips"><a href="#3-15-其他tips" class="headerlink" title="3.15 其他tips"></a>3.15 其他tips</h2><p>复制、粘贴、剪切快捷键</p><ul><li>Ctrl+Insert：复制</li><li>Shift+Insert：粘贴</li><li>Shift+delete：剪切</li></ul><p>自动补全快捷键：</p><ul><li>Ctrl+n</li><li>Ctrl+p</li></ul><p>数字自增（减）1</p><ul><li>Ctrl+a：使光标所在处的数字加1</li><li>Ctrl+x：使光标所在处的数字减1</li><li>.：重复上次命令</li><li>~：对光标下的字母大小写转换</li><li>N<Cmd>：重复Cmd命令N次，可与复制、删除以及其他很多命令搭配使用</li></ul><h1 id="4-参考文件"><a href="#4-参考文件" class="headerlink" title="4. 参考文件"></a>4. 参考文件</h1><p><a href="https://blog.csdn.net/qq_30748863/article/details/84669058">https://blog.csdn.net/qq_30748863/article/details/84669058</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;在说vim之前，先说下什么是vi。vi是visual interface的简称，是Linux中最经典的文本编辑器。vi的</summary>
      
    
    
    
    
    <category term="linux" scheme="http://cakgod.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>gdb使用</title>
    <link href="http://cakgod.github.io/2017/08/13/gdb-using/"/>
    <id>http://cakgod.github.io/2017/08/13/gdb-using/</id>
    <published>2017-08-13T01:33:33.000Z</published>
    <updated>2023-10-12T01:43:11.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>GDB全称GNU symbolic debugger，是GNU开源组织发布的一个强大的Linux下的程序调试工具，GDB主要帮助你完成下面四个方面的功能：</p><ul><li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li><li>可让被调试的程序在你所指定的调置的断点处停住（断点可以是条件表达式）。</li><li>当程序被停住时，可以检查此时你的程序中所发生的事。</li><li>你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。</li></ul><h1 id="2-常用命令介绍"><a href="#2-常用命令介绍" class="headerlink" title="2. 常用命令介绍"></a>2. 常用命令介绍</h1><p>r或run：运行一个待调试的程序</p><p>c或contine：让暂停的程序继续运行</p><p>n或next：运行到下一行</p><p>s或step：单步执行，遇到函数会进入</p><p>u或until：运行到指定行</p><p>fi或finish：结束当前调用的函数，回到上一层函数调用处</p><p>return：结束当前调用函数并返回指定值，到上一层函数调用处</p><p>j或jump：将当前程序执行流跳转到指定行</p><ul><li>jump LineNum：跳转到代码的LineNum行的位置</li><li>jump *address：跳转到address地址的代码处，地址前面要加*</li></ul><p>备注：1.跳过的代码不会被执行；2.跳到的位置如果没有断点那么GDB会继续往下执行</p><p>p或print：打印变量或寄存器的值</p><ul><li>print param：用于在调试过程中查看变量的值</li><li>print param = value：用于在调试过程中修改变量的值为value</li><li>print a+b+c：可以进行一定的表达式运算</li><li>print func()：输出func函数的执行结果，常见用途是打印系统函数执行失败的原因：print strerror(errno)</li><li>print *this：在C++对象中，可以输出当前对象的各成员变量的值</li></ul><p>print不同类型的值</p><ul><li>p/x：十六进制显示</li><li>p/d：十进制显示</li><li>p/u：无符号十进制显示</li><li>p/o：八进制显示</li><li>p/t：二进制显示</li><li>p/a：地址格式显示</li><li>p/c：字符串格式显示</li><li>p/f：浮点数格式显示</li><li>p/s：字符串格式显示</li></ul><p>bt或backtrace：查看当前线程的栈调用</p><p>f或frame：切换到当前调用线程的指定堆栈</p><p>thread：切换到指定线程</p><p>b或break：添加断点</p><ul><li>break FuncName，在函数的入口添加断点</li><li>break LineNum，在当前文件行号为LineNum的代码处添加断点</li><li>break FileName：LineNum，在FileName文件的第LineNum行处添加断点</li><li>break FileName：FuncName，在FileName文件的FuncName函数入口处添加断点</li><li>break -/+offset，在当前程序暂停位置的前/后offset行除添加断点</li><li>break … if cond， 添加条件断点</li></ul><p>tb或tbreak：添加临时断点（第一次执行到后会自动清除，使用方法同break）</p><p>d或delete：删除断点</p><p>enable：启用某个断点</p><p>disable：禁用某个断点</p><p>i或info：查看断点或线程信息</p><p>i/info b，显示当前所有断点的信息</p><p>watch：监视某一个变量或内存地址的值是否发生变化</p><p>l或list：显示源码</p><ul><li>list -，显示上一次list命令显示的代码前面的代码</li><li>list LineNum，显示当前代码文件第LineNum行附近的代码</li><li>list FileName：LineNum，显示FileName文件第LineNum行附近的代码</li><li>list FuncName，显示当前文件FuncName函数附近的代码</li><li>list FileName：FuncName，显示FileName文件的Fun从Name函数附近的代码</li><li>list LineNum1,LineNum2，显示LineNum1到LineNum2之间的代码</li></ul><p>备注：list默认只会输出10行源代码，可以通过show listsize确认list命令显示的代码行数，set listsize count设置list命令显示的的代码行数为conut</p><p>ptype：查看变量类型</p><p>dis或disassemble：查看汇编代码</p><p>set args：设置程序启动命令行参数</p><p>show args：查看设置的命令行参数</p><h1 id="3-GDB的调试方式"><a href="#3-GDB的调试方式" class="headerlink" title="3. GDB的调试方式"></a>3. GDB的调试方式</h1><ul><li>直接调试目标程序</li><li>附加进程id</li><li>调试core文件</li></ul><h1 id="4-GDB的退出"><a href="#4-GDB的退出" class="headerlink" title="4. GDB的退出"></a>4. GDB的退出</h1><p>可以输入命令q或quit退出，或者Ctrl+d退出<br>如果GDB attach某个进程，退出GDB之前要用命令detach解除附加进程</p><h1 id="5-参考文件"><a href="#5-参考文件" class="headerlink" title="5. 参考文件"></a>5. 参考文件</h1><ul><li><a href="https://blog.csdn.net/Jailman/article/details/125847467">https://blog.csdn.net/Jailman/article/details/125847467</a></li><li><a href="https://zhuanlan.zhihu.com/p/297925056">https://zhuanlan.zhihu.com/p/297925056</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;GDB全称GNU symbolic debugger，是GNU开源组织发布的一个强大的Linux下的程序调试工具，GDB</summary>
      
    
    
    
    
    <category term="linux" scheme="http://cakgod.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
