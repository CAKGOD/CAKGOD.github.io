<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="1. 概述本文总结了LLVM IR的一些基本知识。 2. 详述2.1. 生成IR对于以下代码： 12345678910111213&#x2F;&#x2F; factorial.cint factorial(int val, int total)&amp;#123;    if(val&#x3D;&#x3D;1) return total;    return factorial(val-1, val * total);&amp;#125;&#x2F;&#x2F; main">
<meta property="og:type" content="article">
<meta property="og:title" content="LLVM IR解析">
<meta property="og:url" content="http://cakgod.github.io/2021/08/20/llvm-ir/index.html">
<meta property="og:site_name" content="CAKGOD&#39;s blog">
<meta property="og:description" content="1. 概述本文总结了LLVM IR的一些基本知识。 2. 详述2.1. 生成IR对于以下代码： 12345678910111213&#x2F;&#x2F; factorial.cint factorial(int val, int total)&amp;#123;    if(val&#x3D;&#x3D;1) return total;    return factorial(val-1, val * total);&amp;#125;&#x2F;&#x2F; main">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://cakgod.github.io/images/llvm_ir_0.png">
<meta property="og:image" content="http://cakgod.github.io/images/llvm_ir_1.png">
<meta property="og:image" content="http://cakgod.github.io/images/llvm_ir_2.png">
<meta property="og:image" content="http://cakgod.github.io/images/llvm_ir_3.png">
<meta property="og:image" content="http://cakgod.github.io/images/llvm_ir_4.png">
<meta property="og:image" content="http://cakgod.github.io/images/llvm_ir_5.png">
<meta property="og:image" content="http://cakgod.github.io/images/llvm_ir_6.png">
<meta property="og:image" content="http://cakgod.github.io/images/llvm_ir_7.png">
<meta property="og:image" content="http://cakgod.github.io/images/llvm_ir_8.png">
<meta property="og:image" content="http://cakgod.github.io/images/llvm_ir_9.png">
<meta property="og:image" content="http://cakgod.github.io/images/llvm_ir_10.png">
<meta property="og:image" content="http://cakgod.github.io/images/llvm_ir_11.png">
<meta property="article:published_time" content="2021-08-20T05:57:05.000Z">
<meta property="article:modified_time" content="2023-10-23T06:14:04.968Z">
<meta property="article:author" content="CAKGOD">
<meta property="article:tag" content="编译">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cakgod.github.io/images/llvm_ir_0.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>LLVM IR解析</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="CAKGOD's blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2022/10/07/branch-and-optimization/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2021/05/10/compiler-optimization/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://cakgod.github.io/2021/08/20/llvm-ir/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://cakgod.github.io/2021/08/20/llvm-ir/&text=LLVM IR解析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://cakgod.github.io/2021/08/20/llvm-ir/&title=LLVM IR解析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://cakgod.github.io/2021/08/20/llvm-ir/&is_video=false&description=LLVM IR解析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=LLVM IR解析&body=Check out this article: http://cakgod.github.io/2021/08/20/llvm-ir/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://cakgod.github.io/2021/08/20/llvm-ir/&title=LLVM IR解析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://cakgod.github.io/2021/08/20/llvm-ir/&title=LLVM IR解析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://cakgod.github.io/2021/08/20/llvm-ir/&title=LLVM IR解析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://cakgod.github.io/2021/08/20/llvm-ir/&title=LLVM IR解析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://cakgod.github.io/2021/08/20/llvm-ir/&name=LLVM IR解析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://cakgod.github.io/2021/08/20/llvm-ir/&t=LLVM IR解析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%AF%A6%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">2. 详述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%94%9F%E6%88%90IR"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 生成IR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-IR%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. IR的意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-IR%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. IR结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-Target-Information"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1. Target Information</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2. 函数定义的主要结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%BC%BA%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3. 强类型语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-LangRef"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.3.4. LangRef</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Terminator-Instruction"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. Terminator Instruction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-ret"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1. ret</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-br"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2. br</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-switch"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3. switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-unreachable"><span class="toc-number">2.4.4.</span> <span class="toc-text">2.4.4. unreachable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%EF%BC%88Control-Flow-Graph%EF%BC%8CCFG%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">2.5. 控制流图（Control Flow Graph，CFG）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%EF%BC%88Static-Single-Assignment%EF%BC%8CSSA%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">2.6. 静态单赋值（Static Single Assignment，SSA）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-SSA%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.6.1.</span> <span class="toc-text">2.6.1. SSA的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-SSA%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.2.</span> <span class="toc-text">2.6.2. SSA的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-phi%E6%8C%87%E4%BB%A4"><span class="toc-number">2.7.</span> <span class="toc-text">2.7. phi指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-alloca%E6%8C%87%E4%BB%A4"><span class="toc-number">2.8.</span> <span class="toc-text">2.8. alloca指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">2.9.</span> <span class="toc-text">2.9. 全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-Aggregate-Types"><span class="toc-number">2.10.</span> <span class="toc-text">2.10. Aggregate Types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-1-%E6%95%B0%E7%BB%84"><span class="toc-number">2.10.1.</span> <span class="toc-text">2.10.1. 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-2-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.10.2.</span> <span class="toc-text">2.10.2. 结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-getelemtptr%E6%8C%87%E4%BB%A4%EF%BC%88GEP%EF%BC%89"><span class="toc-number">2.11.</span> <span class="toc-text">2.11. getelemtptr指令（GEP）</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        LLVM IR解析
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">CAKGOD</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-08-20T05:57:05.000Z" class="dt-published" itemprop="datePublished">2021-08-20</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/%E7%BC%96%E8%AF%91/" rel="tag">编译</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文总结了LLVM IR的一些基本知识。</p>
<h1 id="2-详述"><a href="#2-详述" class="headerlink" title="2. 详述"></a>2. 详述</h1><h2 id="2-1-生成IR"><a href="#2-1-生成IR" class="headerlink" title="2.1. 生成IR"></a>2.1. 生成IR</h2><p>对于以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factorial.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> total)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(val==<span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="keyword">return</span> factorial(val<span class="number">-1</span>, val * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> factorial(<span class="number">2</span>, <span class="number">1</span>) * <span class="number">7</span> == <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<code>extern &quot;C&quot;</code>是必要的。为了支持C++的函数重载和作用域的可见性的规则，编译器会对函数进行name mangling。如果不加<code>extern &quot;C&quot;</code>，下文中生成的main.ll文件中factorial的函数名会被mangling成类似<code>_Z9factoriali</code>的样子，链接器便找不到要链接的函数。</p>
<p>LLVM IR有两种等价的格式，一种是.bc（Bitcode）文件，另一种是.ll文件，.ll文件是Human-readable的格式。可以使用下面的命令得到这两种格式的IR文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang -S -emit-llvm factorial.c <span class="comment"># factorial.ll</span></span><br><span class="line">$ clang -c -emit-llvm factorial.c <span class="comment"># factorial.bc</span></span><br></pre></td></tr></table></figure>
<p>可以利用grep命令查看clang参数的含义：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ clang --<span class="built_in">help</span> | grep -w -- -[Sc]</span><br><span class="line">-c  Only run preprocess, compile, and assemble steps</span><br><span class="line">-S  Only run preprocess and compilation steps</span><br></pre></td></tr></table></figure>
<p>将两种形式的IR进行转化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ llvm-as factorial.ll <span class="comment"># factorial.bc</span></span><br><span class="line">$ llvm-dis factorial.bc <span class="comment"># factorial.ll</span></span><br></pre></td></tr></table></figure>
<p>对于cpp文件，使用clang++：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -S -emit-llvm main.cpp <span class="comment"># main.ll</span></span><br><span class="line">$ clang++ -c -emit-llvm main.cpp <span class="comment"># main.bc</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-IR的意义"><a href="#2-2-IR的意义" class="headerlink" title="2.2. IR的意义"></a>2.2. IR的意义</h2><p>llvm利用不同高级语言对应的前端（这里C/C++的前端都是clang）将其转化成LLVM IR，进行优化、链接后，传给不同target的后端transform成target-specific的二进制代码。看一下llvm-link将两个IR链接起来的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ llvm-link factorial.bc main.bc -o linked.bc</span><br></pre></td></tr></table></figure>
<p>这样c语言生成的factorial.bc和cpp生成的main.bc合为了一个bc，屏蔽了语言之间的差异。利用llc将IR转化为机器代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ llc --march=x86-64 linked.bc <span class="comment"># linked.s</span></span><br></pre></td></tr></table></figure>
<p>整个流程示意图如下：</p>
<p><img src="/images/llvm_ir_0.png" alt=""></p>
<h2 id="2-3-IR结构"><a href="#2-3-IR结构" class="headerlink" title="2.3. IR结构"></a>2.3. IR结构</h2><p>IR的结构示意图如下：</p>
<p><img src="/images/llvm_ir_1.png" alt=""></p>
<h3 id="2-3-1-Target-Information"><a href="#2-3-1-Target-Information" class="headerlink" title="2.3.1. Target Information"></a>2.3.1. Target Information</h3><p>以linked.ll为例进行解析，文件开头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = &#x27;linked.bc&#x27;</span><br><span class="line">source_filename = &quot;llvm-link&quot;</span><br><span class="line">target datalayout = &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple = &quot;x86_64-unknown-linux-gnu&quot;</span><br></pre></td></tr></table></figure>
<p>Target Information的主要结构如下：</p>
<p><img src="/images/llvm_ir_2.png" alt=""></p>
<h3 id="2-3-2-函数定义的主要结构"><a href="#2-3-2-函数定义的主要结构" class="headerlink" title="2.3.2. 函数定义的主要结构"></a>2.3.2. 函数定义的主要结构</h3><p>函数<code>factorial</code>的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @factorial(i32 %val, i32 %total) #0 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %retval = alloca i32, align 4</span><br><span class="line">  %val.addr = alloca i32, align 4</span><br><span class="line">  %total.addr = alloca i32, align 4</span><br><span class="line">  store i32 %val, i32* %val.addr, align 4</span><br><span class="line">  store i32 %total, i32* %total.addr, align 4</span><br><span class="line">  %0 = load i32, i32* %val.addr, align 4</span><br><span class="line">  %cmp = icmp eq i32 %0, 1</span><br><span class="line">  br i1 %cmp, label %if.then, label %if.end</span><br><span class="line"></span><br><span class="line">if.then:                                          ; preds = %entry</span><br><span class="line">  %1 = load i32, i32* %total.addr, align 4</span><br><span class="line">  store i32 %1, i32* %retval, align 4</span><br><span class="line">  br label %return</span><br><span class="line"></span><br><span class="line">if.end:                                           ; preds = %entry</span><br><span class="line">  %2 = load i32, i32* %val.addr, align 4</span><br><span class="line">  %sub = sub nsw i32 %2, 1</span><br><span class="line">  %3 = load i32, i32* %val.addr, align 4</span><br><span class="line">  %4 = load i32, i32* %total.addr, align 4</span><br><span class="line">  %mul = mul nsw i32 %3, %4</span><br><span class="line">  %call = call i32 @factorial(i32 %sub, i32 %mul)</span><br><span class="line">  store i32 %call, i32* %retval, align 4</span><br><span class="line">  br label %return</span><br><span class="line"></span><br><span class="line">return:                                           ; preds = %if.end, %if.then</span><br><span class="line">  %5 = load i32, i32* %retval, align 4</span><br><span class="line">  ret i32 %5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>;表示单行注释的开始。</li>
<li><code>define dso_local i32 @factorial(i32 %val) #0</code>表明开始定义一个函数，其中第一个i32是返回值类型，对应C语言中的int；%factorial是函数名；第二个i32是形参类型，%val是形参名。</li>
<li>llvm中的标识符分为两种类型：全局的和局部的。全局的标识符包括函数名和全局变量，会加一个@前缀，局部的标识符会加一个%前缀。一般地，可用标识符对应的正则表达式为<code>[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*</code>。</li>
<li><code>dso_local</code>是一个Runtime Preemption说明符，表明该函数会在同一个链接单元（即该函数所在的文件以及包含的头文件）内解析符号。#0指出了该函数的attribute group。在文件的下面会找到类似这样的代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attributes #0 = &#123; noinline nounwind optnone uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;min-legal-vector-width&quot;=&quot;0&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-jump-tables&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;</span><br></pre></td></tr></table></figure>
因为attribute group可能很包含很多attribute且复用到多个函数，所以IR使用attribute group ID（即#0）的形式指明函数的attribute，这样既简洁又清晰。</li>
<li>在一对花括号里的就是函数体，函数体是由一系列基本块（basic blocks，BB）组成的，这些BB形成了函数的控制流图（Control Flow Graph, CFG）。每个BB都有一个label，label使得该BB有一个符号表的入口点，在函数factorial中，这些BB的label就是entry、if.then、if.end，BB总是以terminator instruction（e.g. ret、br、callbr）结尾的。</li>
</ul>
<h3 id="2-3-3-强类型语言"><a href="#2-3-3-强类型语言" class="headerlink" title="2.3.3. 强类型语言"></a>2.3.3. 强类型语言</h3><p>看一下main函数的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; Function Attrs: noinline norecurse optnone uwtable</span><br><span class="line">define dso_local i32 @main(i32 %argc, i8** %argv) #1 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %retval = alloca i32, align 4</span><br><span class="line">  %argc.addr = alloca i32, align 4</span><br><span class="line">  %argv.addr = alloca i8**, align 8</span><br><span class="line">  store i32 0, i32* %retval, align 4</span><br><span class="line">  store i32 %argc, i32* %argc.addr, align 4</span><br><span class="line">  store i8** %argv, i8*** %argv.addr, align 8</span><br><span class="line">  %call = call i32 @factorial(i32 2, i32 1)</span><br><span class="line">  %mul = mul nsw i32 %call, 7</span><br><span class="line">  %cmp = icmp eq i32 %mul, 42</span><br><span class="line">  %conv = zext i1 %cmp to i32</span><br><span class="line">  ret i32 %conv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LLVM的IR是一个强类型语言，每一条指令都显式地指出了实参的类型，例如：</p>
<ul>
<li><code>mul nsw i32 %call</code>, 表明要将两个i32的数值相乘。</li>
<li><code>icmp eq i32 %mul</code>, 表明要将两个i32的数据类型进行相等比较（这里%mul是一个变量，而mul是一条指令，可以看出IR加前缀的好处）。</li>
</ul>
<p>此外，还很容易推断出返回值的类型，比如i32的数相乘的返回值就是i32类型，比较两个数值的相等关系的返回值就是i1类型。</p>
<p>强类型不但使得IR很human readable，也使得在优化IR时不需要考虑隐式类型转换的影响。在main函数的结尾，<code>zext i1 %cmp to i32</code>将<code>%cmp</code>从1位整数扩展成了32位的整数（即做了一个类型提升）。如果把最后两行用以下代码替代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret i32 %cmp</span><br></pre></td></tr></table></figure>
<p>那么这段IR就变成illegal的，检查IR是否合法可以使用<code>opt -verify &lt;filename&gt;</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ opt -verify linked.ll</span><br><span class="line">opt: linked.ll:45:11: error: <span class="string">&#x27;%cmp&#x27;</span> defined with <span class="built_in">type</span> <span class="string">&#x27;i1&#x27;</span> but expected <span class="string">&#x27;i32&#x27;</span></span><br><span class="line">  ret i32 %cmp</span><br></pre></td></tr></table></figure>
<h3 id="2-3-4-LangRef"><a href="#2-3-4-LangRef" class="headerlink" title="2.3.4. LangRef"></a>2.3.4. LangRef</h3><p>看main函数IR中一条：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%call = call i32 @factorial(i32 2)</span><br></pre></td></tr></table></figure>
<p>对照着相应的C++代码很容易可以猜出每个符号的含义，但是每条指令可以有很多的变体，当我们不确定符号的含义的时候，LangRef提供了参考：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = [tail | musttail | notail ] call [fast-math flags] [cconv] [ret attrs] [addrspace(&lt;num&gt;)]</span><br><span class="line">           &lt;ty&gt;|&lt;fnty&gt; &lt;fnptrval&gt;(&lt;function args&gt;) [fn attrs] [ operand bundles ]</span><br></pre></td></tr></table></figure>
<p><code>[]</code>包围的表示可选参数（可以不写），<code>&lt;&gt;</code>包围的表示必选参数，选项用<code>|</code>分格开，表示只能写其中一个。</p>
<h2 id="2-4-Terminator-Instruction"><a href="#2-4-Terminator-Instruction" class="headerlink" title="2.4. Terminator Instruction"></a>2.4. Terminator Instruction</h2><h3 id="2-4-1-ret"><a href="#2-4-1-ret" class="headerlink" title="2.4.1. ret"></a>2.4.1. ret</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret &lt;type&gt; &lt;value&gt;       ; Return a value from a non-void function</span><br><span class="line">ret void                 ; Return from void function</span><br></pre></td></tr></table></figure>
<p>概述：</p>
<p>ret用来将控制流从callee返回给caller。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret i32 5                       ; Return an integer value of 5</span><br><span class="line">ret void                        ; Return from a void function</span><br><span class="line">ret &#123; i32, i8 &#125; &#123; i32 4, i8 2 &#125; ; Return a struct of values 4 and 2</span><br></pre></td></tr></table></figure>
<h3 id="2-4-2-br"><a href="#2-4-2-br" class="headerlink" title="2.4.2. br"></a>2.4.2. br</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;</span><br><span class="line">br label &lt;dest&gt;          ; Unconditional branch</span><br></pre></td></tr></table></figure>
<p>概述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br用来将控制流转交给当前函数中的另一个BB。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Test:</span><br><span class="line">  %cond = icmp eq i32 %a, %b</span><br><span class="line">  br i1 %cond, label %IfEqual, label %IfUnequal</span><br><span class="line">IfEqual:</span><br><span class="line">  ret i32 1</span><br><span class="line">IfUnequal:</span><br><span class="line">  ret i32 0</span><br></pre></td></tr></table></figure>
<h3 id="2-4-3-switch"><a href="#2-4-3-switch" class="headerlink" title="2.4.3. switch"></a>2.4.3. switch</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch &lt;intty&gt; &lt;value&gt;, label &lt;defaultdest&gt; [ &lt;intty&gt; &lt;val&gt;, label &lt;dest&gt; ... ]</span><br></pre></td></tr></table></figure>
<p>概述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch根据一个整型变量的值，将控制流交给不同的BB。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; Emulate a conditional br instruction</span><br><span class="line">%Val = zext i1 %value to i32</span><br><span class="line">switch i32 %Val, label %truedest [ i32 0, label %falsedest ]</span><br><span class="line"></span><br><span class="line">; Emulate an unconditional br instruction</span><br><span class="line">switch i32 0, label %dest [ ]</span><br><span class="line"></span><br><span class="line">; Implement a jump table:</span><br><span class="line">switch i32 %val, label %otherwise [ i32 0, label %onzero</span><br><span class="line">                                    i32 1, label %onone</span><br><span class="line">                                    i32 2, label %ontwo ]</span><br></pre></td></tr></table></figure>
<h3 id="2-4-4-unreachable"><a href="#2-4-4-unreachable" class="headerlink" title="2.4.4. unreachable"></a>2.4.4. unreachable</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unreachable</span><br></pre></td></tr></table></figure>
<p>概述：</p>
<p>unreachable告诉optimizer控制流到不了这块代码，就是说这块代码是dead code。</p>
<p>示例：</p>
<p>先看一下undef的用法。undef表示一个未定义的值，只要是常量可以出现的位置，都可以使用undef。（此Example标题下的代码为伪代码）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%A = or %X, undef</span><br><span class="line">%B = and %X, undef</span><br></pre></td></tr></table></figure>
<p>or指令和and指令分别是执行按位或和按位与的操作，由于undef的值是未定义的，因此编译器可以随意假设它的值来对代码进行优化，譬如说假设undef的值都是0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%A = %X</span><br><span class="line">%B = 0</span><br></pre></td></tr></table></figure>
<p>假设undef的值是-1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%A = -1</span><br><span class="line">%B = %X</span><br></pre></td></tr></table></figure>
<p>也可以假设undef的两处值是不同的，譬如第一处是0，第二处是-1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%A = -1</span><br><span class="line">%B = 0</span><br></pre></td></tr></table></figure>
<p>为什么undef的值可以不同呢？这是因为undef对应的值是没有确定的生存期的，当需要一个undef的值的时候，编译器会从可用的寄存器中随意取一个值拿过来，因此并不能保证其值随时间变化具有一致性。下面可以看unreachable的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%A = sdiv undef, %X</span><br><span class="line">%B = sdiv %X, undef</span><br></pre></td></tr></table></figure>
<p>sdiv指令是用来进行整数/向量的除法运算的，编译器可以假设undef的值是0，因为一个数除以0是未定义行为，因此编译器可以认为其是dead code，将其优化成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%A = 0</span><br><span class="line">unreachable</span><br></pre></td></tr></table></figure>
<h2 id="2-5-控制流图（Control-Flow-Graph，CFG）"><a href="#2-5-控制流图（Control-Flow-Graph，CFG）" class="headerlink" title="2.5. 控制流图（Control Flow Graph，CFG）"></a>2.5. 控制流图（Control Flow Graph，CFG）</h2><p>既然函数体是由一系列BB组成的，并且BB形成了函数的控制流图，每个BB都有唯一的label，那么可以通过label之间的跳转关系来表示整个函数的控制流图，llvm提供了<code>opt -analyze -dot-cfg-only &lt;filename&gt;</code>命令来帮助生成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ opt -analyze -dot-cfg-only factorial.ll</span><br><span class="line">$ vim .factorial.dot</span><br><span class="line">digraph &quot;CFG for &#x27;factorial&#x27; function&quot; &#123;</span><br><span class="line">        label=&quot;CFG for &#x27;factorial&#x27; function&quot;;</span><br><span class="line"></span><br><span class="line">        Node0x207ced0 [shape=record,label=&quot;&#123;entry|&#123;&lt;s0&gt;T|&lt;s1&gt;F&#125;&#125;&quot;];</span><br><span class="line">        Node0x207ced0:s0 -&gt; Node0x207d7e0;</span><br><span class="line">        Node0x207ced0:s1 -&gt; Node0x207d8b0;</span><br><span class="line">        Node0x207d7e0 [shape=record,label=&quot;&#123;if.then&#125;&quot;];</span><br><span class="line">        Node0x207d7e0 -&gt; Node0x207da90;</span><br><span class="line">        Node0x207d8b0 [shape=record,label=&quot;&#123;if.end&#125;&quot;];</span><br><span class="line">        Node0x207d8b0 -&gt; Node0x207da90;</span><br><span class="line">        Node0x207da90 [shape=record,label=&quot;&#123;return&#125;&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-静态单赋值（Static-Single-Assignment，SSA）"><a href="#2-6-静态单赋值（Static-Single-Assignment，SSA）" class="headerlink" title="2.6. 静态单赋值（Static Single Assignment，SSA）"></a>2.6. 静态单赋值（Static Single Assignment，SSA）</h2><p>在IR中，每个变量都在使用前都必须先定义，且每个变量只能被赋值一次（如果套用C++的术语，就是说每个变量只能被初始化，不能被赋值），所以称IR是静态单赋值的。举个例子，假如想返回<code>a*b+c</code>的值，正确和错误的写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; 错误，%0被赋值了两次</span><br><span class="line">%0 = mul i32 %a, %b</span><br><span class="line">%0 = add i32 %0, %c</span><br><span class="line">ret i32 %0</span><br><span class="line"></span><br><span class="line">; 正确</span><br><span class="line">%0 = mul i32 %a, %b</span><br><span class="line">%1 = add i32 %0, %c</span><br><span class="line">ret i32 %1</span><br></pre></td></tr></table></figure>
<h3 id="2-6-1-SSA的好处"><a href="#2-6-1-SSA的好处" class="headerlink" title="2.6.1. SSA的好处"></a>2.6.1. SSA的好处</h3><p>SSA可以简化编译器的优化过程，譬如说，考虑这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1: y := 1</span><br><span class="line">d2: y := 2</span><br><span class="line">d3: x := y</span><br></pre></td></tr></table></figure>
<p>可以看出第一次对y赋值是不必要的，在对x赋值时使用的y的值时第二次赋值的结果，但是编译器必须要经过一个定义可达性（Reaching definition）分析才能做出判断。编译器是怎么分析呢？首先先介绍几个概念：</p>
<ul>
<li><em>变量x的定义</em>是指一个会给x赋值或可能给x赋值的语句，譬如d1就是对y的一个定义。当一个变量y有新的定义后，旧的的定义会被新的定义kill掉，譬如d2就kill掉了d1。</li>
<li><em>d到达p</em>是指存在一条d到p路径，在这条路径上，d没有被kill掉。</li>
<li><em>t1是t2的reaching definition</em>是指存在一条t1到t2路径，沿着这条路径走就可以得到t1要赋值的变量的值，而不需要额外的信息。</li>
</ul>
<p>按照上面的代码写法，编译器是很难判断d3的reaching definition的。因为d3的reaching definition可能是d1，也可能是d2，要搞清楚d1和d2谁kill了谁很麻烦。但是，如果我们的代码是SSA的，则代码就会长成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1: y1 := 1</span><br><span class="line">d2: y2 := 2</span><br><span class="line">d3: x := y2</span><br></pre></td></tr></table></figure>
<p>编译发现x是由y2赋值得到，而y2被赋值了2，且x和y2都只能被赋值一次，显然得到x的值的路径就是唯一确定的，d2就是d3的reaching definition。</p>
<h3 id="2-6-2-SSA的问题"><a href="#2-6-2-SSA的问题" class="headerlink" title="2.6.2. SSA的问题"></a>2.6.2. SSA的问题</h3><p>假设你想用IR写一个用循环实现的factorial函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int factorial(int val)</span><br><span class="line">&#123;</span><br><span class="line">    int temp = 1;</span><br><span class="line">    for (int i = 2; i &lt;= val; ++i) &#123;</span><br><span class="line">        temp *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照C语言的思路，大概会写成这样：</p>
<p><img src="/images/llvm_ir_3.png" alt=""></p>
<p>跑<code>opt -verify &lt;filename&gt;</code>命令就会发现%temp和%i被多次赋值了，这不合法。但是如果把第二处的%temp和%i换掉，改成这样：</p>
<p><img src="/images/llvm_ir_4.png" alt=""></p>
<p>那返回值就会永远是1。可以引入<code>phi</code>或<code>alloca</code>来解决该问题。</p>
<h2 id="2-7-phi指令"><a href="#2-7-phi指令" class="headerlink" title="2.7. phi指令"></a>2.7. phi指令</h2><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = phi &lt;ty&gt; [&lt;val0&gt;, &lt;label0&gt;], [&lt;val1&gt;, &lt;label1&gt;] …</span><br></pre></td></tr></table></figure>
<p>概述：</p>
<p>根据前一个执行的是哪一个BB来选择一个变量的值。有了phi指令，我们就可以把代码改成这样：</p>
<p><img src="/images/llvm_ir_5.png" alt=""></p>
<p>这样的话，每个变量就只被赋值一次，并且实现了循环递增的效果。</p>
<h2 id="2-8-alloca指令"><a href="#2-8-alloca指令" class="headerlink" title="2.8. alloca指令"></a>2.8. alloca指令</h2><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = alloca [inalloca] &lt;type&gt; [, &lt;ty&gt; &lt;NumElements&gt;] [, align &lt;alignment&gt;] [, addrspace(&lt;num&gt;)]</span><br></pre></td></tr></table></figure>
<p>概述：</p>
<p>在当前执行的函数的栈帧上分配内存并返回一个指向这片内存的指针，当函数返回时内存会被自动释放（一般是改变栈指针）。<br>有了alloca指令，我们也可以通过使用指针的方式间接多次对变量赋值来骗过SSA检查。</p>
<p>这样代码就可以写成这样：</p>
<p><img src="/images/llvm_ir_6.png" alt=""></p>
<h2 id="2-9-全局变量"><a href="#2-9-全局变量" class="headerlink" title="2.9. 全局变量"></a>2.9. 全局变量</h2><p>IR中的全局变量定义了一块在编译期分配的内存区域，其类型是一个指针，跟指令alloca的返回值用法一样。我们看一下一段使用全局变量简单的C代码对应的IR：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// a.c</span><br><span class="line">static const int a=0;</span><br><span class="line">const int b=1;</span><br><span class="line">const int c=1;</span><br><span class="line">int d=a+1;</span><br><span class="line"></span><br><span class="line">; a.ll</span><br><span class="line">@b = dso_local constant i32 1, align 4</span><br><span class="line">@c = dso_local constant i32 1, align 4</span><br><span class="line">@d = dso_local global i32 1, align 4</span><br></pre></td></tr></table></figure>
<p>前面已经讲过<code>dso_local</code>是一个Runtime Preemption，表明该变量会在同一个链接单元内解析符号，<code>align 4</code>表示4字节对齐。global和constant关键字都可以用来定义一个全局变量，全局变量名必须有<code>@</code>前缀，因为全局变量会参与链接，所以除去前缀外，其名字会跟你用C语言定义时的相同。因为定义变量a时使用了C语言的static关键字，也就是说a是local to file的，不参与链接，因此可以在生成的IR中可以看到，其被优化掉了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// b.c</span><br><span class="line">extern const int b;</span><br><span class="line">extern const int c;</span><br><span class="line">extern const int d;</span><br><span class="line"></span><br><span class="line">int f() &#123;</span><br><span class="line">  return b*c+d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; b.ll</span><br><span class="line">@b = external dso_local constant i32, align 4</span><br><span class="line">@c = external dso_local constant i32, align 4</span><br><span class="line">@d = external dso_local constant i32, align 4</span><br><span class="line"></span><br><span class="line">define dso_local i32 @f() #0 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %0 = load i32, i32* @b, align 4</span><br><span class="line">  %1 = load i32, i32* @c, align 4</span><br><span class="line">  %mul = mul nsw i32 %0, %1</span><br><span class="line">  %2 = load i32, i32* @d, align 4</span><br><span class="line">  %add = add nsw i32 %mul, %2</span><br><span class="line">  ret i32 %add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从函数f的IR可以看到，全局变量其实是一个指针，在使用其时需要load指令（赋值时需要store指令）。那gloal和constant有什么区别呢？constant相比global，多赋予了全局变量一个const属性（对应C++的底层const的概念，表示指针指向的对象是一个常量）。跟C/C++类似，IR中可以在定义全局变量时使用global，而在声明全局变量时使用constant，表示该变量在本文件内不改变其值。</p>
<p>可以使用<code>opt -S --globalopt &lt;filename&gt;</code>命令对全局变量进行优化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ opt -S --globalopt a.ll -o a-opt.ll</span><br><span class="line">@b = dso_local local_unnamed_addr constant i32 1, align 4</span><br><span class="line">@c = dso_local local_unnamed_addr constant i32 1, align 4</span><br><span class="line">@d = dso_local local_unnamed_addr global i32 1, align 4</span><br></pre></td></tr></table></figure>
<p>可以看到优化过，全局变量前多了<code>local_unnamed_addr</code>的<code>attribute</code>, 该属性表明在这个module内，这个变量的地址是不重要的，只要关心它的值就好。有什么作用呢？譬如说这里b和c都是常量且等于1，又有<code>local_unnamed_addr</code>属性，编译器就可以把b和c合并成一个变量。</p>
<h2 id="2-10-Aggregate-Types"><a href="#2-10-Aggregate-Types" class="headerlink" title="2.10. Aggregate Types"></a>2.10. Aggregate Types</h2><p>IR的Aggregate Types包括数组和结构体。</p>
<h3 id="2-10-1-数组"><a href="#2-10-1-数组" class="headerlink" title="2.10.1. 数组"></a>2.10.1. 数组</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;elementnumber&gt; x &lt;elementtype&gt;]</span><br></pre></td></tr></table></figure>
<p>概述：</p>
<p>跟C++的模板类<code>template&lt;class T, std::size_t N &gt; class array</code>类似，数组元素在内存中是连续分布的，元素个数必须是编译器常量，未被提供初始值的元素会被零初始化，只是下标的使用方式有点区别。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@array = global [17 x i8] ; 17个i8都是0</span><br><span class="line">%array2 = alloca [17 x i8] [i8 1, i8 2] ; 前两个是1、2，其余是0</span><br><span class="line">%array3 = alloca [3 x [4 x i32]] ; 3行4列的i32数组</span><br><span class="line">@array4 = global [2 x [3 x [4 x i16]]] ; 2x3x4的i16数组</span><br></pre></td></tr></table></figure>
<h3 id="2-10-2-结构体"><a href="#2-10-2-结构体" class="headerlink" title="2.10.2. 结构体"></a>2.10.2. 结构体</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%T1 = type &#123; &lt;type list&gt; &#125;     ; Identified normal struct type</span><br><span class="line">%T2 = type &lt;&#123; &lt;type list&gt; &#125;&gt;   ; Identified packed struct type</span><br></pre></td></tr></table></figure>
<p>概述：</p>
<p>与C语言中的struct相同，不过IR提供了两种版本，normal版元素之间是由padding的，packed版没有。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%struct1 = type &#123; i32, i32, i32 &#125; ; 一个i32的triple</span><br><span class="line">%struct2 = type &#123; float, i32 (i32) * &#125; ; 一个pair，第一个元素是float，第二个元素是一个函数指针，该函数有一个i32的形参，返回一个i32 </span><br><span class="line">%struct3 = type &lt;&#123; i8, i32 &#125;&gt; ; 一个packed的pair，大小为5字节</span><br></pre></td></tr></table></figure>
<h2 id="2-11-getelemtptr指令（GEP）"><a href="#2-11-getelemtptr指令（GEP）" class="headerlink" title="2.11. getelemtptr指令（GEP）"></a>2.11. getelemtptr指令（GEP）</h2><p>可以使用getelementptr指令来获得指向数组的元素和指向结构体成员的指针。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = getelementptr &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;*</span><br><span class="line">&lt;result&gt; = getelementptr inbounds &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;*</span><br></pre></td></tr></table></figure>
<p>概述：</p>
<p>第一个ty是第一个索引使用的基本类型，第二个ty表示其后的基址ptrval的类型。 <code>&lt;ty&gt; &lt;idx&gt;</code>是第一组索引的类型和值，<code>&lt;ty&gt; &lt;idx&gt;</code>可以出现多次，其后出现的就是第二组、第三组等等索引的类型和值。要注意索引的类型和索引使用的基本类型是不一样的，索引的类型一般为i32或i64，而索引使用的基本类型确定的是增加索引值时指针的偏移量。</p>
<p>GEP有几个要点：</p>
<p>（1）第一个索引不会改变返回的指针的类型，也就是说ptrval前面的<code>&lt;ty&gt;*</code>对应什么类型，返回就是什么类型。<br>（2）第一个索引的偏移量的是由第一个索引的值和第一个ty指定的基本类型共同确定的。</p>
<p>可以看下边的示例：</p>
<p><img src="/images/llvm_ir_7.png" alt=""></p>
<p>上图中第一个索引所使用的基本类型是[6 x i8]，值是1，所以返回的值相对基址<code>@a_gv</code>前进了6个字节。由于只有一个索引，所以返回的指针也是<code>[6 x i8]*</code>类型。</p>
<p>再看下两个要点：</p>
<p>（1）后面的索引是在Aggregate Types内进行索引。<br>（2）每增加一个索引，就会使得该索引使用的基本类型和返回的指针的类型去掉一层。</p>
<p>可以看下边的示例：</p>
<p><img src="/images/llvm_ir_8.png" alt=""></p>
<p>看<code>%elem_ptr = getelementptr [6 x i8], [6 x i8]* @a_gv, i32 0, i32 0</code>这一句，第一个索引值是0，使用的基本类型[6 x i8], 因此其使返回的指针先前进<code>0 x 6</code>个字节，也就是不前进，第二个索引的值是1，使用的基本类型就是i8（[6 x i8]去掉左边的6），因此其使返回的指针前进一个字节，返回的指针类型为<code>i8*</code>（<code>[6 x i8]*</code>去掉左边的6）。</p>
<p>看一下GEP如何作用于结构体：</p>
<p><img src="/images/llvm_ir_9.png" alt=""></p>
<p>只有一个索引情况下，GEP作用于结构体与作用于数组的规则相同，<code>%new_ptr = getelementptr %MyStruct*, %MyStruct* @a_gv, i32 1</code>使得<code>%new_ptr</code>相对<code>@a_gv</code>偏移一个结构体<code>%MyStruct</code>的大小。</p>
<p><img src="/images/llvm_ir_10.png" alt=""></p>
<p>在有两个索引的情况下，第二个索引对返回指针的影响跟结构体的成员类型有关。譬如说在上图中，第二个索引值是1，那么返回的指针就会偏移到第二个成员，也就是偏移1个字节，由于第二个成员是i32类型，因此返回的指针是<code>i32*</code>。</p>
<p><img src="/images/llvm_ir_11.png" alt=""></p>
<p>如果结构体的本身也有Aggregate Type的成员，就会出现超过两个索引的情况。第三个索引将会进入这个Aggregate Type成员进行索引。譬如说上图中的第二个索引是2，指针先指向第三个成员，第三个成员是个数组。再看第三个索引是0，因此指针就指向该成员的第一个元素，指针类型也变成了<code>i32*</code>。</p>
<p>注意：GEP作用于结构体时，其索引一定要是常量。GEP指令只是返回一个偏移后的指针，并没有访问内存。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%AF%A6%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">2. 详述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%94%9F%E6%88%90IR"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 生成IR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-IR%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. IR的意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-IR%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. IR结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-Target-Information"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1. Target Information</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2. 函数定义的主要结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%BC%BA%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3. 强类型语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-LangRef"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.3.4. LangRef</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Terminator-Instruction"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. Terminator Instruction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-ret"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1. ret</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-br"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2. br</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-switch"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3. switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-unreachable"><span class="toc-number">2.4.4.</span> <span class="toc-text">2.4.4. unreachable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%EF%BC%88Control-Flow-Graph%EF%BC%8CCFG%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">2.5. 控制流图（Control Flow Graph，CFG）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%EF%BC%88Static-Single-Assignment%EF%BC%8CSSA%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">2.6. 静态单赋值（Static Single Assignment，SSA）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-SSA%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.6.1.</span> <span class="toc-text">2.6.1. SSA的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-SSA%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.2.</span> <span class="toc-text">2.6.2. SSA的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-phi%E6%8C%87%E4%BB%A4"><span class="toc-number">2.7.</span> <span class="toc-text">2.7. phi指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-alloca%E6%8C%87%E4%BB%A4"><span class="toc-number">2.8.</span> <span class="toc-text">2.8. alloca指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">2.9.</span> <span class="toc-text">2.9. 全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-Aggregate-Types"><span class="toc-number">2.10.</span> <span class="toc-text">2.10. Aggregate Types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-1-%E6%95%B0%E7%BB%84"><span class="toc-number">2.10.1.</span> <span class="toc-text">2.10.1. 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-2-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.10.2.</span> <span class="toc-text">2.10.2. 结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-getelemtptr%E6%8C%87%E4%BB%A4%EF%BC%88GEP%EF%BC%89"><span class="toc-number">2.11.</span> <span class="toc-text">2.11. getelemtptr指令（GEP）</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://cakgod.github.io/2021/08/20/llvm-ir/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://cakgod.github.io/2021/08/20/llvm-ir/&text=LLVM IR解析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://cakgod.github.io/2021/08/20/llvm-ir/&title=LLVM IR解析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://cakgod.github.io/2021/08/20/llvm-ir/&is_video=false&description=LLVM IR解析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=LLVM IR解析&body=Check out this article: http://cakgod.github.io/2021/08/20/llvm-ir/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://cakgod.github.io/2021/08/20/llvm-ir/&title=LLVM IR解析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://cakgod.github.io/2021/08/20/llvm-ir/&title=LLVM IR解析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://cakgod.github.io/2021/08/20/llvm-ir/&title=LLVM IR解析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://cakgod.github.io/2021/08/20/llvm-ir/&title=LLVM IR解析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://cakgod.github.io/2021/08/20/llvm-ir/&name=LLVM IR解析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://cakgod.github.io/2021/08/20/llvm-ir/&t=LLVM IR解析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    CAKGOD
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>
